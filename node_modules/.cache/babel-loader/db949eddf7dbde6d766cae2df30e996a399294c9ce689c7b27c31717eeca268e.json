{"ast":null,"code":"import _regeneratorRuntime from \"/Users/aadar00/Documents/image-moderation-app/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/aadar00/Documents/image-moderation-app/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/aadar00/Documents/image-moderation-app/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/aadar00/Documents/image-moderation-app/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { removeNils, clone } from '../util/object.js';\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport { isLocalhost, isIE11OrLess } from '../features.js';\nimport { REFRESH_TOKEN_STORAGE_KEY, TOKEN_STORAGE_NAME } from '../constants.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport 'cross-fetch';\nimport { validateToken as _validateToken } from './util/validateToken.js';\nimport SdkClock from '../clock.js';\nimport { isRefreshToken, isAccessToken, isIDToken } from './types/Token.js';\nimport { EVENT_EXPIRED, EVENT_RENEWED, EVENT_ADDED, EVENT_REMOVED, EVENT_ERROR, EVENT_SET_STORAGE } from './types/TokenManager.js';\nvar DEFAULT_OPTIONS = {\n  autoRenew: true,\n  autoRemove: true,\n  syncStorage: true,\n  clearPendingRemoveTokens: true,\n  storage: undefined,\n  expireEarlySeconds: 30,\n  storageKey: TOKEN_STORAGE_NAME\n};\nfunction defaultState() {\n  return {\n    expireTimeouts: {},\n    renewPromise: null\n  };\n}\nvar TokenManager = /*#__PURE__*/function () {\n  function TokenManager(sdk) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, TokenManager);\n    this.sdk = sdk;\n    this.emitter = sdk.emitter;\n    if (!this.emitter) {\n      throw new AuthSdkError('Emitter should be initialized before TokenManager');\n    }\n    options = Object.assign({}, DEFAULT_OPTIONS, removeNils(options));\n    if (!isLocalhost()) {\n      options.expireEarlySeconds = DEFAULT_OPTIONS.expireEarlySeconds;\n    }\n    this.options = options;\n    var storageOptions = removeNils({\n      storageKey: options.storageKey,\n      secure: options.secure\n    });\n    if (typeof options.storage === 'object') {\n      storageOptions.storageProvider = options.storage;\n    } else if (options.storage) {\n      storageOptions.storageType = options.storage;\n    }\n    this.storage = sdk.storageManager.getTokenStorage(Object.assign(Object.assign({}, storageOptions), {\n      useSeparateCookies: true\n    }));\n    this.clock = SdkClock.create();\n    this.state = defaultState();\n  }\n  _createClass(TokenManager, [{\n    key: \"on\",\n    value: function on(event, handler, context) {\n      if (context) {\n        this.emitter.on(event, handler, context);\n      } else {\n        this.emitter.on(event, handler);\n      }\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, handler) {\n      if (handler) {\n        this.emitter.off(event, handler);\n      } else {\n        this.emitter.off(event);\n      }\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.options.clearPendingRemoveTokens) {\n        this.clearPendingRemoveTokens();\n      }\n      this.setExpireEventTimeoutAll();\n      this.state.started = true;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.clearExpireEventTimeoutAll();\n      this.state.started = false;\n    }\n  }, {\n    key: \"isStarted\",\n    value: function isStarted() {\n      return !!this.state.started;\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      return clone(this.options);\n    }\n  }, {\n    key: \"getExpireTime\",\n    value: function getExpireTime(token) {\n      var expireEarlySeconds = this.options.expireEarlySeconds || 0;\n      var expireTime = token.expiresAt - expireEarlySeconds;\n      return expireTime;\n    }\n  }, {\n    key: \"hasExpired\",\n    value: function hasExpired(token) {\n      var expireTime = this.getExpireTime(token);\n      return expireTime <= this.clock.now();\n    }\n  }, {\n    key: \"emitExpired\",\n    value: function emitExpired(key, token) {\n      this.emitter.emit(EVENT_EXPIRED, key, token);\n    }\n  }, {\n    key: \"emitRenewed\",\n    value: function emitRenewed(key, freshToken, oldToken) {\n      this.emitter.emit(EVENT_RENEWED, key, freshToken, oldToken);\n    }\n  }, {\n    key: \"emitAdded\",\n    value: function emitAdded(key, token) {\n      this.emitter.emit(EVENT_ADDED, key, token);\n    }\n  }, {\n    key: \"emitRemoved\",\n    value: function emitRemoved(key, token) {\n      this.emitter.emit(EVENT_REMOVED, key, token);\n    }\n  }, {\n    key: \"emitError\",\n    value: function emitError(error) {\n      this.emitter.emit(EVENT_ERROR, error);\n    }\n  }, {\n    key: \"clearExpireEventTimeout\",\n    value: function clearExpireEventTimeout(key) {\n      clearTimeout(this.state.expireTimeouts[key]);\n      delete this.state.expireTimeouts[key];\n      this.state.renewPromise = null;\n    }\n  }, {\n    key: \"clearExpireEventTimeoutAll\",\n    value: function clearExpireEventTimeoutAll() {\n      var expireTimeouts = this.state.expireTimeouts;\n      for (var key in expireTimeouts) {\n        if (!Object.prototype.hasOwnProperty.call(expireTimeouts, key)) {\n          continue;\n        }\n        this.clearExpireEventTimeout(key);\n      }\n    }\n  }, {\n    key: \"setExpireEventTimeout\",\n    value: function setExpireEventTimeout(key, token) {\n      var _this = this;\n      if (isRefreshToken(token)) {\n        return;\n      }\n      var expireTime = this.getExpireTime(token);\n      var expireEventWait = Math.max(expireTime - this.clock.now(), 0) * 1000;\n      this.clearExpireEventTimeout(key);\n      var expireEventTimeout = setTimeout(function () {\n        _this.emitExpired(key, token);\n      }, expireEventWait);\n      this.state.expireTimeouts[key] = expireEventTimeout;\n    }\n  }, {\n    key: \"setExpireEventTimeoutAll\",\n    value: function setExpireEventTimeoutAll() {\n      var tokenStorage = this.storage.getStorage();\n      for (var key in tokenStorage) {\n        if (!Object.prototype.hasOwnProperty.call(tokenStorage, key)) {\n          continue;\n        }\n        var token = tokenStorage[key];\n        this.setExpireEventTimeout(key, token);\n      }\n    }\n  }, {\n    key: \"resetExpireEventTimeoutAll\",\n    value: function resetExpireEventTimeoutAll() {\n      this.clearExpireEventTimeoutAll();\n      this.setExpireEventTimeoutAll();\n    }\n  }, {\n    key: \"add\",\n    value: function add(key, token) {\n      var tokenStorage = this.storage.getStorage();\n      _validateToken(token);\n      tokenStorage[key] = token;\n      this.storage.setStorage(tokenStorage);\n      this.emitSetStorageEvent();\n      this.emitAdded(key, token);\n      this.setExpireEventTimeout(key, token);\n    }\n  }, {\n    key: \"getSync\",\n    value: function getSync(key) {\n      var tokenStorage = this.storage.getStorage();\n      return tokenStorage[key];\n    }\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", this.getSync(key));\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function get(_x) {\n        return _get.apply(this, arguments);\n      }\n      return get;\n    }()\n  }, {\n    key: \"getTokensSync\",\n    value: function getTokensSync() {\n      var tokens = {};\n      var tokenStorage = this.storage.getStorage();\n      Object.keys(tokenStorage).forEach(function (key) {\n        var token = tokenStorage[key];\n        if (isAccessToken(token)) {\n          tokens.accessToken = token;\n        } else if (isIDToken(token)) {\n          tokens.idToken = token;\n        } else if (isRefreshToken(token)) {\n          tokens.refreshToken = token;\n        }\n      });\n      return tokens;\n    }\n  }, {\n    key: \"getTokens\",\n    value: function () {\n      var _getTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", this.getTokensSync());\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function getTokens() {\n        return _getTokens.apply(this, arguments);\n      }\n      return getTokens;\n    }()\n  }, {\n    key: \"getStorageKeyByType\",\n    value: function getStorageKeyByType(type) {\n      var tokenStorage = this.storage.getStorage();\n      var key = Object.keys(tokenStorage).filter(function (key) {\n        var token = tokenStorage[key];\n        return isAccessToken(token) && type === 'accessToken' || isIDToken(token) && type === 'idToken' || isRefreshToken(token) && type === 'refreshToken';\n      })[0];\n      return key;\n    }\n  }, {\n    key: \"getTokenType\",\n    value: function getTokenType(token) {\n      if (isAccessToken(token)) {\n        return 'accessToken';\n      }\n      if (isIDToken(token)) {\n        return 'idToken';\n      }\n      if (isRefreshToken(token)) {\n        return 'refreshToken';\n      }\n      throw new AuthSdkError('Unknown token type');\n    }\n  }, {\n    key: \"emitSetStorageEvent\",\n    value: function emitSetStorageEvent() {\n      if (isIE11OrLess()) {\n        var storage = this.storage.getStorage();\n        this.emitter.emit(EVENT_SET_STORAGE, storage);\n      }\n    }\n  }, {\n    key: \"getStorage\",\n    value: function getStorage() {\n      return this.storage;\n    }\n  }, {\n    key: \"setTokens\",\n    value: function setTokens(tokens, accessTokenCb, idTokenCb, refreshTokenCb) {\n      var _this2 = this;\n      var handleTokenCallback = function handleTokenCallback(key, token) {\n        var type = _this2.getTokenType(token);\n        if (type === 'accessToken') {\n          accessTokenCb && accessTokenCb(key, token);\n        } else if (type === 'idToken') {\n          idTokenCb && idTokenCb(key, token);\n        } else if (type === 'refreshToken') {\n          refreshTokenCb && refreshTokenCb(key, token);\n        }\n      };\n      var handleAdded = function handleAdded(key, token) {\n        _this2.emitAdded(key, token);\n        _this2.setExpireEventTimeout(key, token);\n        handleTokenCallback(key, token);\n      };\n      var handleRenewed = function handleRenewed(key, token, oldToken) {\n        _this2.emitRenewed(key, token, oldToken);\n        _this2.clearExpireEventTimeout(key);\n        _this2.setExpireEventTimeout(key, token);\n        handleTokenCallback(key, token);\n      };\n      var handleRemoved = function handleRemoved(key, token) {\n        _this2.clearExpireEventTimeout(key);\n        _this2.emitRemoved(key, token);\n        handleTokenCallback(key, token);\n      };\n      var types = ['idToken', 'accessToken', 'refreshToken'];\n      var existingTokens = this.getTokensSync();\n      types.forEach(function (type) {\n        var token = tokens[type];\n        if (token) {\n          _validateToken(token, type);\n        }\n      });\n      var storage = types.reduce(function (storage, type) {\n        var token = tokens[type];\n        if (token) {\n          var storageKey = _this2.getStorageKeyByType(type) || type;\n          storage[storageKey] = token;\n        }\n        return storage;\n      }, {});\n      this.storage.setStorage(storage);\n      this.emitSetStorageEvent();\n      types.forEach(function (type) {\n        var newToken = tokens[type];\n        var existingToken = existingTokens[type];\n        var storageKey = _this2.getStorageKeyByType(type) || type;\n        if (newToken && existingToken) {\n          handleRemoved(storageKey, existingToken);\n          handleAdded(storageKey, newToken);\n          handleRenewed(storageKey, newToken, existingToken);\n        } else if (newToken) {\n          handleAdded(storageKey, newToken);\n        } else if (existingToken) {\n          handleRemoved(storageKey, existingToken);\n        }\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      this.clearExpireEventTimeout(key);\n      var tokenStorage = this.storage.getStorage();\n      var removedToken = tokenStorage[key];\n      delete tokenStorage[key];\n      this.storage.setStorage(tokenStorage);\n      this.emitSetStorageEvent();\n      this.emitRemoved(key, removedToken);\n    }\n  }, {\n    key: \"renewToken\",\n    value: function () {\n      var _renewToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(token) {\n        var _a;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", (_a = this.sdk.token) === null || _a === void 0 ? void 0 : _a.renew(token));\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function renewToken(_x2) {\n        return _renewToken.apply(this, arguments);\n      }\n      return renewToken;\n    }()\n  }, {\n    key: \"validateToken\",\n    value: function validateToken(token) {\n      return _validateToken(token);\n    }\n  }, {\n    key: \"renew\",\n    value: function renew(key) {\n      var _this3 = this;\n      if (this.state.renewPromise) {\n        return this.state.renewPromise;\n      }\n      try {\n        var token = this.getSync(key);\n        if (!token) {\n          throw new AuthSdkError('The tokenManager has no token for the key: ' + key);\n        }\n      } catch (e) {\n        return Promise.reject(e);\n      }\n      this.clearExpireEventTimeout(key);\n      var renewPromise = this.state.renewPromise = this.sdk.token.renewTokens().then(function (tokens) {\n        _this3.setTokens(tokens);\n        var tokenType = _this3.getTokenType(token);\n        return tokens[tokenType];\n      }).catch(function (err) {\n        _this3.remove(key);\n        err.tokenKey = key;\n        _this3.emitError(err);\n        throw err;\n      }).finally(function () {\n        _this3.state.renewPromise = null;\n      });\n      return renewPromise;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this4 = this;\n      var tokens = this.getTokensSync();\n      this.clearExpireEventTimeoutAll();\n      this.storage.clearStorage();\n      this.emitSetStorageEvent();\n      Object.keys(tokens).forEach(function (key) {\n        _this4.emitRemoved(key, tokens[key]);\n      });\n    }\n  }, {\n    key: \"clearPendingRemoveTokens\",\n    value: function clearPendingRemoveTokens() {\n      var _this5 = this;\n      var tokenStorage = this.storage.getStorage();\n      var removedTokens = {};\n      Object.keys(tokenStorage).forEach(function (key) {\n        if (tokenStorage[key].pendingRemove) {\n          removedTokens[key] = tokenStorage[key];\n          delete tokenStorage[key];\n        }\n      });\n      this.storage.setStorage(tokenStorage);\n      this.emitSetStorageEvent();\n      Object.keys(removedTokens).forEach(function (key) {\n        _this5.clearExpireEventTimeout(key);\n        _this5.emitRemoved(key, removedTokens[key]);\n      });\n    }\n  }, {\n    key: \"updateRefreshToken\",\n    value: function updateRefreshToken(token) {\n      var key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n      var tokenStorage = this.storage.getStorage();\n      _validateToken(token);\n      tokenStorage[key] = token;\n      this.storage.setStorage(tokenStorage);\n      this.emitSetStorageEvent();\n    }\n  }, {\n    key: \"removeRefreshToken\",\n    value: function removeRefreshToken() {\n      var key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n      this.remove(key);\n    }\n  }, {\n    key: \"addPendingRemoveFlags\",\n    value: function addPendingRemoveFlags() {\n      var tokens = this.getTokensSync();\n      Object.keys(tokens).forEach(function (key) {\n        tokens[key].pendingRemove = true;\n      });\n      this.setTokens(tokens);\n    }\n  }]);\n  return TokenManager;\n}();\nexport { TokenManager };","map":{"version":3,"names":["DEFAULT_OPTIONS","autoRenew","autoRemove","syncStorage","clearPendingRemoveTokens","storage","undefined","expireEarlySeconds","storageKey","TOKEN_STORAGE_NAME","defaultState","expireTimeouts","renewPromise","TokenManager","sdk","options","arguments","length","_classCallCheck","emitter","AuthSdkError","Object","assign","removeNils","isLocalhost","storageOptions","secure","storageProvider","storageType","storageManager","getTokenStorage","useSeparateCookies","clock","SdkClock","create","state","_createClass","key","value","on","event","handler","context","off","start","setExpireEventTimeoutAll","started","stop","clearExpireEventTimeoutAll","isStarted","getOptions","clone","getExpireTime","token","expireTime","expiresAt","hasExpired","now","emitExpired","emit","EVENT_EXPIRED","emitRenewed","freshToken","oldToken","EVENT_RENEWED","emitAdded","EVENT_ADDED","emitRemoved","EVENT_REMOVED","emitError","error","EVENT_ERROR","clearExpireEventTimeout","clearTimeout","prototype","hasOwnProperty","call","setExpireEventTimeout","_this","isRefreshToken","expireEventWait","Math","max","expireEventTimeout","setTimeout","tokenStorage","getStorage","resetExpireEventTimeoutAll","add","validateToken","setStorage","emitSetStorageEvent","getSync","_get","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","abrupt","get","_x","apply","getTokensSync","tokens","keys","forEach","isAccessToken","accessToken","isIDToken","idToken","refreshToken","_getTokens","_callee2","_callee2$","_context2","getTokens","getStorageKeyByType","type","filter","getTokenType","isIE11OrLess","EVENT_SET_STORAGE","setTokens","accessTokenCb","idTokenCb","refreshTokenCb","_this2","handleTokenCallback","handleAdded","handleRenewed","handleRemoved","types","existingTokens","reduce","newToken","existingToken","remove","removedToken","_renewToken","_callee3","_a","_callee3$","_context3","renew","renewToken","_x2","_this3","e","Promise","reject","renewTokens","then","tokenType","catch","err","tokenKey","finally","clear","_this4","clearStorage","_this5","removedTokens","pendingRemove","updateRefreshToken","REFRESH_TOKEN_STORAGE_KEY","removeRefreshToken","addPendingRemoveFlags"],"sources":["/Users/aadar00/Documents/image-moderation-app/frontend/node_modules/@okta/lib/oidc/TokenManager.ts"],"sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n *\n */\nimport { removeNils, clone } from '../util';\nimport { AuthSdkError } from '../errors';\nimport { validateToken  } from '../oidc/util';\nimport { isLocalhost, isIE11OrLess } from '../features';\nimport SdkClock from '../clock';\nimport {\n  Token, \n  Tokens, \n  TokenType, \n  TokenManagerOptions, \n  isIDToken, \n  isAccessToken,\n  isRefreshToken,\n  TokenManagerErrorEventHandler,\n  TokenManagerSetStorageEventHandler,\n  TokenManagerRenewEventHandler,\n  TokenManagerEventHandler,\n  TokenManagerInterface,\n  RefreshToken,\n  AccessTokenCallback,\n  IDTokenCallback,\n  RefreshTokenCallback,\n  EVENT_RENEWED,\n  EVENT_ADDED,\n  EVENT_ERROR,\n  EVENT_EXPIRED,\n  EVENT_REMOVED,\n  EVENT_SET_STORAGE,\n  TokenManagerAnyEventHandler,\n  TokenManagerAnyEvent,\n  OktaAuthOAuthInterface\n} from './types';\nimport { REFRESH_TOKEN_STORAGE_KEY, TOKEN_STORAGE_NAME } from '../constants';\nimport { EventEmitter } from '../base/types';\nimport { StorageOptions, StorageProvider, StorageType } from '../storage/types';\n\nconst DEFAULT_OPTIONS = {\n  // TODO: remove in next major version - OKTA-473815\n  autoRenew: true,\n  autoRemove: true,\n  syncStorage: true,\n  // --- //\n  clearPendingRemoveTokens: true,\n  storage: undefined, // will use value from storageManager config\n  expireEarlySeconds: 30,\n  storageKey: TOKEN_STORAGE_NAME\n};\n\ninterface TokenManagerState {\n  expireTimeouts: Record<string, unknown>;\n  renewPromise: Promise<Token | undefined> | null;\n  started?: boolean;\n}\nfunction defaultState(): TokenManagerState {\n  return {\n    expireTimeouts: {},\n    renewPromise: null\n  };\n}\nexport class TokenManager implements TokenManagerInterface {\n  private sdk: OktaAuthOAuthInterface;\n  private clock: SdkClock;\n  private emitter: EventEmitter;\n  private storage: StorageProvider;\n  private state: TokenManagerState;\n  private options: TokenManagerOptions;\n\n  on(event: typeof EVENT_RENEWED, handler: TokenManagerRenewEventHandler, context?: object): void;\n  on(event: typeof EVENT_ERROR, handler: TokenManagerErrorEventHandler, context?: object): void;\n  on(event: typeof EVENT_SET_STORAGE, handler: TokenManagerSetStorageEventHandler, context?: object): void;\n  on(event: typeof EVENT_EXPIRED | typeof EVENT_ADDED | typeof EVENT_REMOVED, \n    handler: TokenManagerEventHandler, context?: object): void;\n  on(event: TokenManagerAnyEvent, handler: TokenManagerAnyEventHandler, context?: object): void {\n    if (context) {\n      this.emitter.on(event, handler, context);\n    } else {\n      this.emitter.on(event, handler);\n    }\n  }\n\n  off(event: typeof EVENT_RENEWED, handler?: TokenManagerRenewEventHandler): void;\n  off(event: typeof EVENT_ERROR, handler?: TokenManagerErrorEventHandler): void;\n  off(event: typeof EVENT_SET_STORAGE, handler?: TokenManagerSetStorageEventHandler): void;\n  off(event: typeof EVENT_EXPIRED | typeof EVENT_ADDED | typeof EVENT_REMOVED, \n    handler?: TokenManagerEventHandler): void;\n  off(event: TokenManagerAnyEvent, handler?: TokenManagerAnyEventHandler): void {\n    if (handler) {\n      this.emitter.off(event, handler);\n    } else {\n      this.emitter.off(event);\n    }\n  }\n\n  // eslint-disable-next-line complexity\n  constructor(sdk: OktaAuthOAuthInterface, options: TokenManagerOptions = {}) {\n    this.sdk = sdk;\n    this.emitter = (sdk as any).emitter;\n    if (!this.emitter) {\n      throw new AuthSdkError('Emitter should be initialized before TokenManager');\n    }\n    \n    options = Object.assign({}, DEFAULT_OPTIONS, removeNils(options));\n    if (!isLocalhost()) {\n      options.expireEarlySeconds = DEFAULT_OPTIONS.expireEarlySeconds;\n    }\n\n    this.options = options;\n\n    const storageOptions: StorageOptions = removeNils({\n      storageKey: options.storageKey,\n      secure: options.secure,\n    });\n    if (typeof options.storage === 'object') {\n      // A custom storage provider must implement getItem(key) and setItem(key, val)\n      storageOptions.storageProvider = options.storage;\n    } else if (options.storage) {\n      storageOptions.storageType = options.storage as StorageType;\n    }\n\n    this.storage = sdk.storageManager.getTokenStorage({...storageOptions, useSeparateCookies: true});\n    this.clock = SdkClock.create(/* sdk, options */);\n    this.state = defaultState();\n  }\n\n  start() {\n    if (this.options.clearPendingRemoveTokens) {\n      this.clearPendingRemoveTokens();\n    }\n    this.setExpireEventTimeoutAll();\n    this.state.started = true;\n  }\n  \n  stop() {\n    this.clearExpireEventTimeoutAll();\n    this.state.started = false;\n  }\n\n  isStarted() {\n    return !!this.state.started;\n  }\n\n  getOptions(): TokenManagerOptions {\n    return clone(this.options);\n  }\n  \n  getExpireTime(token) {\n    const expireEarlySeconds = this.options.expireEarlySeconds || 0;\n    var expireTime = token.expiresAt - expireEarlySeconds;\n    return expireTime;\n  }\n  \n  hasExpired(token) {\n    var expireTime = this.getExpireTime(token);\n    return expireTime <= this.clock.now();\n  }\n  \n  emitExpired(key, token) {\n    this.emitter.emit(EVENT_EXPIRED, key, token);\n  }\n  \n  emitRenewed(key, freshToken, oldToken) {\n    this.emitter.emit(EVENT_RENEWED, key, freshToken, oldToken);\n  }\n  \n  emitAdded(key, token) {\n    this.emitter.emit(EVENT_ADDED, key, token);\n  }\n  \n  emitRemoved(key, token?) {\n    this.emitter.emit(EVENT_REMOVED, key, token);\n  }\n  \n  emitError(error) {\n    this.emitter.emit(EVENT_ERROR, error);\n  }\n  \n  clearExpireEventTimeout(key) {\n    clearTimeout(this.state.expireTimeouts[key] as any);\n    delete this.state.expireTimeouts[key];\n  \n    // Remove the renew promise (if it exists)\n    this.state.renewPromise = null;\n  }\n  \n  clearExpireEventTimeoutAll() {\n    var expireTimeouts = this.state.expireTimeouts;\n    for (var key in expireTimeouts) {\n      if (!Object.prototype.hasOwnProperty.call(expireTimeouts, key)) {\n        continue;\n      }\n      this.clearExpireEventTimeout(key);\n    }\n  }\n  \n  setExpireEventTimeout(key, token) {\n    if (isRefreshToken(token)) {\n      return;\n    }\n\n    var expireTime = this.getExpireTime(token);\n    var expireEventWait = Math.max(expireTime - this.clock.now(), 0) * 1000;\n  \n    // Clear any existing timeout\n    this.clearExpireEventTimeout(key);\n  \n    var expireEventTimeout = setTimeout(() => {\n      this.emitExpired(key, token);\n    }, expireEventWait);\n  \n    // Add a new timeout\n    this.state.expireTimeouts[key] = expireEventTimeout;\n  }\n  \n  setExpireEventTimeoutAll() {\n    var tokenStorage = this.storage.getStorage();\n    for(var key in tokenStorage) {\n      if (!Object.prototype.hasOwnProperty.call(tokenStorage, key)) {\n        continue;\n      }\n      var token = tokenStorage[key];\n      this.setExpireEventTimeout(key, token);\n    }\n  }\n  \n  // reset timeouts to setup autoRenew for tokens from other document context (tabs)\n  resetExpireEventTimeoutAll() {\n    this.clearExpireEventTimeoutAll();\n    this.setExpireEventTimeoutAll();\n  }\n  \n  add(key, token: Token) {\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    this.emitAdded(key, token);\n    this.setExpireEventTimeout(key, token);\n  }\n  \n  getSync(key): Token | undefined {\n    var tokenStorage = this.storage.getStorage();\n    return tokenStorage[key];\n  }\n  \n  async get(key): Promise<Token | undefined> {\n    return this.getSync(key);\n  }\n  \n  getTokensSync(): Tokens {\n    const tokens = {} as Tokens;\n    const tokenStorage = this.storage.getStorage();\n    Object.keys(tokenStorage).forEach(key => {\n      const token = tokenStorage[key];\n      if (isAccessToken(token)) {\n        tokens.accessToken = token;\n      } else if (isIDToken(token)) {\n        tokens.idToken = token;\n      } else if (isRefreshToken(token)) { \n        tokens.refreshToken = token;\n      }\n    });\n    return tokens;\n  }\n  \n  async getTokens(): Promise<Tokens> {\n    return this.getTokensSync();\n  }\n\n  getStorageKeyByType(type: TokenType): string {\n    const tokenStorage = this.storage.getStorage();\n    const key = Object.keys(tokenStorage).filter(key => {\n      const token = tokenStorage[key];\n      return (isAccessToken(token) && type === 'accessToken') \n        || (isIDToken(token) && type === 'idToken')\n        || (isRefreshToken(token) && type === 'refreshToken');\n    })[0];\n    return key;\n  }\n\n  private getTokenType(token: Token): TokenType {\n    if (isAccessToken(token)) {\n      return 'accessToken';\n    }\n    if (isIDToken(token)) {\n      return 'idToken';\n    }\n    if(isRefreshToken(token)) {\n      return 'refreshToken';\n    }\n    throw new AuthSdkError('Unknown token type');\n  }\n\n  // for synchronization of LocalStorage cross tabs for IE11\n  private emitSetStorageEvent() {\n    if (isIE11OrLess()) {\n      const storage = this.storage.getStorage();\n      this.emitter.emit(EVENT_SET_STORAGE, storage);\n    }\n  }\n\n  // used in `SyncStorageService` for synchronization of LocalStorage cross tabs for IE11\n  public getStorage() {\n    return this.storage;\n  }\n\n  setTokens(\n    tokens: Tokens,\n    // TODO: callbacks can be removed in the next major version OKTA-407224\n    accessTokenCb?: AccessTokenCallback, \n    idTokenCb?: IDTokenCallback,\n    refreshTokenCb?: RefreshTokenCallback\n  ): void {\n    const handleTokenCallback = (key, token) => {\n      const type = this.getTokenType(token);\n      if (type === 'accessToken') {\n        accessTokenCb && accessTokenCb(key, token);\n      } else if (type === 'idToken') {\n        idTokenCb && idTokenCb(key, token);\n      } else if (type === 'refreshToken') {\n        refreshTokenCb && refreshTokenCb(key, token);\n      }\n    };\n    const handleAdded = (key, token) => {\n      this.emitAdded(key, token);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n    const handleRenewed = (key, token, oldToken) => {\n      this.emitRenewed(key, token, oldToken);\n      this.clearExpireEventTimeout(key);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n    const handleRemoved = (key, token) => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, token);\n      handleTokenCallback(key, token);\n    };\n    \n    const types: TokenType[] = ['idToken', 'accessToken', 'refreshToken'];\n    const existingTokens = this.getTokensSync();\n\n    // valid tokens\n    types.forEach((type) => {\n      const token = tokens[type];\n      if (token) {\n        validateToken(token, type);\n      }\n    });\n  \n    // add token to storage\n    const storage = types.reduce((storage, type) => {\n      const token = tokens[type];\n      if (token) {\n        const storageKey = this.getStorageKeyByType(type) || type;\n        storage[storageKey] = token;\n      }\n      return storage;\n    }, {});\n    this.storage.setStorage(storage);\n    this.emitSetStorageEvent();\n\n    // emit event and start expiration timer\n    types.forEach(type => {\n      const newToken = tokens[type];\n      const existingToken = existingTokens[type];\n      const storageKey = this.getStorageKeyByType(type) || type;\n      if (newToken && existingToken) { // renew\n        // call handleRemoved first, since it clears timers\n        handleRemoved(storageKey, existingToken);\n        handleAdded(storageKey, newToken);\n        handleRenewed(storageKey, newToken, existingToken);\n      } else if (newToken) { // add\n        handleAdded(storageKey, newToken);\n      } else if (existingToken) { //remove\n        handleRemoved(storageKey, existingToken);\n      }\n    });\n  }\n  \n  remove(key) {\n    // Clear any listener for this token\n    this.clearExpireEventTimeout(key);\n  \n    var tokenStorage = this.storage.getStorage();\n    var removedToken = tokenStorage[key];\n    delete tokenStorage[key];\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n  \n    this.emitRemoved(key, removedToken);\n  }\n  \n  // TODO: this methods is redundant and can be removed in the next major version OKTA-407224\n  async renewToken(token) {\n    return this.sdk.token?.renew(token);\n  }\n  // TODO: this methods is redundant and can be removed in the next major version OKTA-407224\n  validateToken(token: Token) {\n    return validateToken(token);\n  }\n\n  // TODO: renew method should take no param, change in the next major version OKTA-407224\n  renew(key): Promise<Token | undefined> {\n    // Multiple callers may receive the same promise. They will all resolve or reject from the same request.\n    if (this.state.renewPromise) {\n      return this.state.renewPromise;\n    }\n  \n    try {\n      var token = this.getSync(key);\n      if (!token) {\n        throw new AuthSdkError('The tokenManager has no token for the key: ' + key);\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  \n    // Remove existing autoRenew timeout\n    this.clearExpireEventTimeout(key);\n  \n    // A refresh token means a replace instead of renewal\n    // Store the renew promise state, to avoid renewing again\n    const renewPromise = this.state.renewPromise = this.sdk.token.renewTokens()\n      .then(tokens => {\n        this.setTokens(tokens);\n\n        // resolve token based on the key\n        const tokenType = this.getTokenType(token!);\n        return tokens[tokenType];\n      })\n      .catch(err => {\n        // If renew fails, remove token from storage and emit error\n        this.remove(key);\n        err.tokenKey = key;\n        this.emitError(err);\n        throw err;\n      })\n      .finally(() => {\n        // Remove existing promise key\n        this.state.renewPromise = null;\n      });\n  \n    return renewPromise;\n  }\n  \n  clear() {\n    const tokens = this.getTokensSync();\n    this.clearExpireEventTimeoutAll();\n    this.storage.clearStorage();\n    this.emitSetStorageEvent();\n\n    Object.keys(tokens).forEach(key => {\n      this.emitRemoved(key, tokens[key]);\n    });\n  }\n\n  clearPendingRemoveTokens() {\n    const tokenStorage = this.storage.getStorage();\n    const removedTokens = {};\n    Object.keys(tokenStorage).forEach(key => {\n      if (tokenStorage[key].pendingRemove) {\n        removedTokens[key] = tokenStorage[key];\n        delete tokenStorage[key];\n      }\n    });\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    Object.keys(removedTokens).forEach(key => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, removedTokens[key]);\n    });\n  }\n\n  updateRefreshToken(token: RefreshToken) {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n\n    // do not emit any event\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n  }\n\n  removeRefreshToken () {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n    this.remove(key);\n  }\n\n  addPendingRemoveFlags() {\n    const tokens = this.getTokensSync();\n    Object.keys(tokens).forEach(key => {\n      tokens[key].pendingRemove = true;\n    });\n    this.setTokens(tokens);\n  }\n  \n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}