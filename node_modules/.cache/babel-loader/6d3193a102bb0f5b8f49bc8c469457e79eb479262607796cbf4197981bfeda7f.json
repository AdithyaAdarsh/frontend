{"ast":null,"code":"/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport { getRemediator, handleFailedResponse, isTerminalResponse, filterValuesForRemediation, getNextStep } from './util.js';\nfunction getActionFromValues(values, idxResponse) {\n  return Object.keys(idxResponse.actions).find(action => !!values.resend && action.includes('-resend'));\n}\nfunction removeActionFromValues(values) {\n  return Object.assign(Object.assign({}, values), {\n    resend: undefined\n  });\n}\nfunction removeActionFromOptions(options, actionName) {\n  let actions = options.actions || [];\n  actions = actions.filter(entry => {\n    if (typeof entry === 'string') {\n      return entry !== actionName;\n    }\n    return entry.name !== actionName;\n  });\n  return Object.assign(Object.assign({}, options), {\n    actions\n  });\n}\nasync function remediate(authClient, idxResponse, values, options) {\n  let {\n    neededToProceed,\n    interactionCode\n  } = idxResponse;\n  const {\n    flow\n  } = options;\n  if (interactionCode) {\n    return {\n      idxResponse\n    };\n  }\n  const remediator = getRemediator(idxResponse, values, options);\n  const actionFromValues = getActionFromValues(values, idxResponse);\n  const actionFromOptions = options.actions || [];\n  const actions = [...actionFromOptions, ...(actionFromValues && [actionFromValues] || [])];\n  if (actions) {\n    for (let action of actions) {\n      let params = {};\n      if (typeof action !== 'string') {\n        params = action.params || {};\n        action = action.name;\n      }\n      let valuesWithoutExecutedAction = removeActionFromValues(values);\n      let optionsWithoutExecutedAction = removeActionFromOptions(options, action);\n      if (typeof idxResponse.actions[action] === 'function') {\n        idxResponse = await idxResponse.actions[action](params);\n        if (idxResponse.requestDidSucceed === false) {\n          return handleFailedResponse(authClient, idxResponse, options);\n        }\n        if (action === 'cancel') {\n          return {\n            idxResponse,\n            canceled: true\n          };\n        }\n        return remediate(authClient, idxResponse, valuesWithoutExecutedAction, optionsWithoutExecutedAction);\n      }\n      const remediationAction = neededToProceed.find(({\n        name\n      }) => name === action);\n      if (remediationAction) {\n        idxResponse = await idxResponse.proceed(action, params);\n        if (idxResponse.requestDidSucceed === false) {\n          return handleFailedResponse(authClient, idxResponse, options);\n        }\n        return remediate(authClient, idxResponse, values, optionsWithoutExecutedAction);\n      }\n    }\n  }\n  const terminal = isTerminalResponse(idxResponse);\n  if (terminal) {\n    return {\n      idxResponse,\n      terminal\n    };\n  }\n  if (!remediator) {\n    if (options.step) {\n      values = filterValuesForRemediation(idxResponse, options.step, values);\n      idxResponse = await idxResponse.proceed(options.step, values);\n      if (idxResponse.requestDidSucceed === false) {\n        return handleFailedResponse(authClient, idxResponse, options);\n      }\n      return {\n        idxResponse\n      };\n    }\n    if (flow === 'default') {\n      return {\n        idxResponse\n      };\n    }\n    throw new AuthSdkError(`\n      No remediation can match current flow, check policy settings in your org.\n      Remediations: [${neededToProceed.reduce((acc, curr) => acc ? acc + ' ,' + curr.name : curr.name, '')}]\n    `);\n  }\n  if (!remediator.canRemediate()) {\n    const nextStep = getNextStep(authClient, remediator, idxResponse);\n    return {\n      idxResponse,\n      nextStep\n    };\n  }\n  const name = remediator.getName();\n  const data = remediator.getData();\n  idxResponse = await idxResponse.proceed(name, data);\n  if (idxResponse.requestDidSucceed === false) {\n    return handleFailedResponse(authClient, idxResponse, options);\n  }\n  values = remediator.getValuesAfterProceed();\n  options = Object.assign(Object.assign({}, options), {\n    step: undefined\n  });\n  if (options.useGenericRemediator && !idxResponse.interactionCode && !isTerminalResponse(idxResponse)) {\n    const gr = getRemediator(idxResponse, values, options);\n    const nextStep = getNextStep(authClient, gr, idxResponse);\n    return {\n      idxResponse,\n      nextStep\n    };\n  }\n  return remediate(authClient, idxResponse, values, options);\n}\nexport { remediate };","map":{"version":3,"names":["getActionFromValues","values","idxResponse","Object","keys","actions","find","action","resend","includes","removeActionFromValues","assign","undefined","removeActionFromOptions","options","actionName","filter","entry","name","remediate","authClient","neededToProceed","interactionCode","flow","remediator","getRemediator","actionFromValues","actionFromOptions","params","valuesWithoutExecutedAction","optionsWithoutExecutedAction","requestDidSucceed","handleFailedResponse","canceled","remediationAction","proceed","terminal","isTerminalResponse","step","filterValuesForRemediation","AuthSdkError","reduce","acc","curr","canRemediate","nextStep","getNextStep","getName","data","getData","getValuesAfterProceed","useGenericRemediator","gr"],"sources":["/Users/aadar00/Documents/image-moderation-app/frontend/node_modules/@okta/lib/idx/remediate.ts"],"sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\n\n/* eslint-disable max-statements, max-depth, complexity */\nimport { AuthSdkError } from '../errors';\nimport { RemediationValues } from './remediators';\nimport { OktaAuthIdxInterface, RemediateOptions, RemediationResponse } from './types';\nimport { \n  IdxResponse,\n  IdxActionParams, \n} from './types/idx-js';\nimport {\n  isTerminalResponse,\n  filterValuesForRemediation,\n  getRemediator,\n  getNextStep,\n  handleFailedResponse\n} from './util';\n\nexport interface RemediateActionWithOptionalParams {\n  name: string;\n  params?: IdxActionParams;\n}\n\nexport type RemediateAction = string | RemediateActionWithOptionalParams;\n\n\nfunction getActionFromValues(values: RemediationValues, idxResponse: IdxResponse): string | undefined {\n  // Currently support resend actions only\n  return Object.keys(idxResponse.actions).find(action => !!values.resend && action.includes('-resend'));\n}\n\nfunction removeActionFromValues(values: RemediationValues): RemediationValues {\n  // Currently support resend actions only\n  return {\n    ...values,\n    resend: undefined\n  };\n}\n\nfunction removeActionFromOptions(options: RemediateOptions, actionName: string): RemediateOptions {\n  let actions = options.actions || [];\n  actions = actions.filter(entry => {\n    if (typeof entry === 'string') {\n      return entry !== actionName;\n    }\n    return entry.name !== actionName;\n  });\n\n  return { ...options, actions };\n}\n\n// This function is called recursively until it reaches success or cannot be remediated\nexport async function remediate(\n  authClient: OktaAuthIdxInterface,\n  idxResponse: IdxResponse,\n  values: RemediationValues,\n  options: RemediateOptions\n): Promise<RemediationResponse> {\n  let { neededToProceed, interactionCode } = idxResponse;\n  const { flow } = options;\n\n  // If the response contains an interaction code, there is no need to remediate\n  if (interactionCode) {\n    return { idxResponse };\n  }\n\n  const remediator = getRemediator(idxResponse, values, options);\n\n  // Try actions in idxResponse first\n  const actionFromValues = getActionFromValues(values, idxResponse);\n  const actionFromOptions = options.actions || [];\n  const actions = [\n    ...actionFromOptions,\n    ...(actionFromValues && [actionFromValues] || []),\n  ];\n  if (actions) {\n    for (let action of actions) {\n      // Action can either be specified as a string, or as an object with name and optional params\n      let params: IdxActionParams = {};\n      if (typeof action !== 'string') {\n        params = action.params || {};\n        action = action.name;\n      }\n      let valuesWithoutExecutedAction = removeActionFromValues(values);\n      let optionsWithoutExecutedAction = removeActionFromOptions(options, action);\n\n      if (typeof idxResponse.actions[action] === 'function') {\n        idxResponse = await idxResponse.actions[action](params);\n        if (idxResponse.requestDidSucceed === false) {\n          return handleFailedResponse(authClient, idxResponse, options);\n        }\n        if (action === 'cancel') {\n          return { idxResponse, canceled: true };\n        }\n        return remediate(\n          authClient, \n          idxResponse, \n          valuesWithoutExecutedAction, \n          optionsWithoutExecutedAction\n        ); // recursive call\n      }\n\n      // search for action in remediation list\n      const remediationAction = neededToProceed.find(({ name }) => name === action);\n      if (remediationAction) {\n        idxResponse = await idxResponse.proceed(action, params);\n        if (idxResponse.requestDidSucceed === false) {\n          return handleFailedResponse(authClient, idxResponse, options);\n        }\n        return remediate(authClient, idxResponse, values, optionsWithoutExecutedAction); // recursive call\n      }\n    }\n  }\n\n  // Do not attempt to remediate if response is in terminal state\n  const terminal = isTerminalResponse(idxResponse);\n  if (terminal) {\n    return { idxResponse, terminal };\n  }\n\n  if (!remediator) {\n    // With options.step, remediator is not required\n    if (options.step) {\n      values = filterValuesForRemediation(idxResponse, options.step, values); // include only requested values\n      idxResponse = await idxResponse.proceed(options.step, values);\n      if (idxResponse.requestDidSucceed === false) {\n        return handleFailedResponse(authClient, idxResponse, options);\n      }\n      return { idxResponse };\n    }\n\n    // With default flow, remediator is not required\n    if (flow === 'default') {\n      return { idxResponse };\n    }\n    throw new AuthSdkError(`\n      No remediation can match current flow, check policy settings in your org.\n      Remediations: [${neededToProceed.reduce((acc, curr) => acc ? acc + ' ,' + curr.name : curr.name, '')}]\n    `);\n  }\n\n  // Return next step to the caller\n  if (!remediator.canRemediate()) {\n    const nextStep = getNextStep(authClient, remediator, idxResponse);\n    return {\n      idxResponse,\n      nextStep,\n    };\n  }\n\n  const name = remediator.getName();\n  const data = remediator.getData();\n\n  idxResponse = await idxResponse.proceed(name, data);\n  if (idxResponse.requestDidSucceed === false) {\n    return handleFailedResponse(authClient, idxResponse, options);\n  }\n  // We may want to trim the values bag for the next remediation\n  // Let the remediator decide what the values should be (default to current values)\n  values = remediator.getValuesAfterProceed();\n  options = { ...options, step: undefined }; // do not re-use the step\n\n  // generic remediator should not auto proceed in pending status\n  // return nextStep directly\n  if (options.useGenericRemediator && !idxResponse.interactionCode && !isTerminalResponse(idxResponse)) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const gr = getRemediator(idxResponse, values, options)!;\n    const nextStep = getNextStep(authClient, gr, idxResponse);\n    return {\n      idxResponse,\n      nextStep,\n    };\n  }\n  \n  return remediate(authClient, idxResponse, values, options); // recursive call\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}