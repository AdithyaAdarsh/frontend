{"ast":null,"code":"import _slicedToArray from \"/Users/aadar00/Documents/image-moderation-app/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { __rest } from '../../../_virtual/_tslib.js';\nimport { generateRemediationFunctions } from './remediationParser.js';\nimport generateIdxAction from './generateIdxAction.js';\nimport { jsonpath } from '../../../util/jsonpath.js';\nimport AuthSdkError from '../../../errors/AuthSdkError.js';\nvar SKIP_FIELDS = Object.fromEntries(['remediation', 'context'].map(function (field) {\n  return [field, !!'skip this field'];\n}));\nvar parseNonRemediations = function parseNonRemediations(authClient, idxResponse) {\n  var toPersist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var actions = {};\n  var context = {};\n  Object.keys(idxResponse).filter(function (field) {\n    return !SKIP_FIELDS[field];\n  }).forEach(function (field) {\n    var fieldIsObject = typeof idxResponse[field] === 'object' && !!idxResponse[field];\n    if (!fieldIsObject) {\n      context[field] = idxResponse[field];\n      return;\n    }\n    if (idxResponse[field].rel) {\n      actions[idxResponse[field].name] = generateIdxAction(authClient, idxResponse[field], toPersist);\n      return;\n    }\n    var _a = idxResponse[field],\n      fieldValue = _a.value,\n      type = _a.type,\n      info = __rest(_a, [\"value\", \"type\"]);\n    context[field] = Object.assign({\n      type: type\n    }, info);\n    if (type !== 'object') {\n      context[field].value = fieldValue;\n      return;\n    }\n    context[field].value = {};\n    Object.entries(fieldValue).forEach(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        subField = _ref2[0],\n        value = _ref2[1];\n      if (value.rel) {\n        actions[\"\".concat(field, \"-\").concat(subField.name || subField)] = generateIdxAction(authClient, value, toPersist);\n      } else {\n        context[field].value[subField] = value;\n      }\n    });\n  });\n  return {\n    context: context,\n    actions: actions\n  };\n};\nvar expandRelatesTo = function expandRelatesTo(idxResponse, value) {\n  Object.keys(value).forEach(function (k) {\n    if (k === 'relatesTo') {\n      var query = Array.isArray(value[k]) ? value[k][0] : value[k];\n      if (typeof query === 'string') {\n        var result = jsonpath({\n          path: query,\n          json: idxResponse\n        })[0];\n        if (result) {\n          value[k] = result;\n          return;\n        } else {\n          throw new AuthSdkError(\"Cannot resolve relatesTo: \".concat(query));\n        }\n      }\n    }\n    if (Array.isArray(value[k])) {\n      value[k].forEach(function (innerValue) {\n        return expandRelatesTo(idxResponse, innerValue);\n      });\n    }\n  });\n};\nvar convertRemediationAction = function convertRemediationAction(authClient, remediation, toPersist) {\n  if (remediation.rel) {\n    var remediationActions = generateRemediationFunctions(authClient, [remediation], toPersist);\n    var actionFn = remediationActions[remediation.name];\n    return Object.assign(Object.assign({}, remediation), {\n      action: actionFn\n    });\n  }\n  return remediation;\n};\nvar parseIdxResponse = function parseIdxResponse(authClient, idxResponse) {\n  var toPersist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a;\n  var remediationData = ((_a = idxResponse.remediation) === null || _a === void 0 ? void 0 : _a.value) || [];\n  remediationData.forEach(function (remediation) {\n    return expandRelatesTo(idxResponse, remediation);\n  });\n  var remediations = remediationData.map(function (remediation) {\n    return convertRemediationAction(authClient, remediation, toPersist);\n  });\n  var _parseNonRemediations = parseNonRemediations(authClient, idxResponse, toPersist),\n    context = _parseNonRemediations.context,\n    actions = _parseNonRemediations.actions;\n  return {\n    remediations: remediations,\n    context: context,\n    actions: actions\n  };\n};\nexport { parseIdxResponse, parseNonRemediations };","map":{"version":3,"names":["SKIP_FIELDS","Object","fromEntries","map","field","parseNonRemediations","authClient","idxResponse","toPersist","arguments","length","undefined","actions","context","keys","filter","forEach","fieldIsObject","rel","name","generateIdxAction","_a","fieldValue","value","type","info","__rest","assign","entries","_ref","_ref2","_slicedToArray","subField","concat","expandRelatesTo","k","query","Array","isArray","result","jsonpath","path","json","AuthSdkError","innerValue","convertRemediationAction","remediation","remediationActions","generateRemediationFunctions","actionFn","action","parseIdxResponse","remediationData","remediations","_parseNonRemediations"],"sources":["/Users/aadar00/Documents/image-moderation-app/frontend/node_modules/@okta/lib/idx/idxState/v1/idxResponseParser.ts"],"sourcesContent":["/*!\n * Copyright (c) 2021-Present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n */\n\n/* eslint-disable max-len */\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\nimport { OktaAuthIdxInterface } from '../../types';    // auth-js/types\nimport { generateRemediationFunctions } from './remediationParser';\nimport generateIdxAction from './generateIdxAction';\nimport { jsonpath } from '../../../util/jsonpath';\nimport { AuthSdkError } from '../../../errors';\n\nconst SKIP_FIELDS = Object.fromEntries([\n  'remediation', // remediations are put into proceed/neededToProceed\n  'context', // the API response of 'context' isn't externally useful.  We ignore it and put all non-action (contextual) info into idxState.context\n].map( (field) => [ field, !!'skip this field' ] ));\n\nexport const parseNonRemediations = function parseNonRemediations( authClient: OktaAuthIdxInterface, idxResponse, toPersist = {} ) {\n  const actions = {};\n  const context = {};\n\n  Object.keys(idxResponse)\n    .filter( field => !SKIP_FIELDS[field])\n    .forEach( field => {\n      const fieldIsObject = typeof idxResponse[field] === 'object' && !!idxResponse[field];\n\n      if ( !fieldIsObject ) {\n        // simple fields are contextual info\n        context[field] = idxResponse[field];\n        return;\n      }\n\n      if ( idxResponse[field].rel ) {\n        // top level actions\n        actions[idxResponse[field].name] = generateIdxAction(authClient, idxResponse[field], toPersist);\n        return;\n      }\n\n      const { value: fieldValue, type, ...info} = idxResponse[field];\n      context[field] = { type, ...info}; // add the non-action parts as context\n\n      if ( type !== 'object' ) {\n        // only object values hold actions\n        context[field].value = fieldValue;\n        return;\n      }\n\n      // We are an object field containing an object value\n      context[field].value = {};\n      Object.entries(fieldValue)\n        .forEach( ([subField, value]) => {\n          if (value.rel) { // is [field].value[subField] an action?\n            // add any \"action\" value subfields to actions\n            actions[`${field}-${subField.name || subField}`] = generateIdxAction(authClient, value, toPersist);\n          } else {\n            // add non-action value subfields to context\n            context[field].value[subField] = value;\n          }\n        });\n    });\n\n  return { context, actions };\n};\n\nconst expandRelatesTo = (idxResponse, value) => {\n  Object.keys(value).forEach(k => {\n    if (k === 'relatesTo') {\n      const query = Array.isArray(value[k]) ? value[k][0] : value[k];\n      if (typeof query === 'string') {\n        const result = jsonpath({ path: query, json: idxResponse })[0];\n        if (result) {\n          value[k] = result;\n          return;\n        } else {\n          throw new AuthSdkError(`Cannot resolve relatesTo: ${query}`);\n        }\n      }\n    }\n    if (Array.isArray(value[k])) {\n      value[k].forEach(innerValue => expandRelatesTo(idxResponse, innerValue));\n    }\n  });\n};\n\nconst convertRemediationAction = (authClient: OktaAuthIdxInterface, remediation, toPersist) => {\n  // Only remediation that has `rel` field (indicator for form submission) can have http action\n  if (remediation.rel) {\n    const remediationActions = generateRemediationFunctions( authClient, [remediation], toPersist );\n    const actionFn = remediationActions[remediation.name];\n    return {\n      ...remediation,\n      action: actionFn,\n    };\n  }\n\n  return remediation;\n};\n\nexport const parseIdxResponse = function parseIdxResponse( authClient: OktaAuthIdxInterface, idxResponse, toPersist = {} ): {\n  remediations: IdxRemediation[];\n  context: IdxContext;\n  actions: IdxActions;\n} {\n  const remediationData = idxResponse.remediation?.value || [];\n\n  remediationData.forEach(\n    remediation => expandRelatesTo(idxResponse, remediation)\n  );\n\n  const remediations = remediationData.map(remediation => convertRemediationAction( authClient, remediation, toPersist ));\n\n  const { context, actions } = parseNonRemediations( authClient, idxResponse, toPersist );\n\n  return {\n    remediations,\n    context,\n    actions,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}