{"ast":null,"code":"/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { __rest } from '../../_virtual/_tslib.js';\nimport * as index from '../../crypto/index.js';\nimport { httpRequest } from '../../http/request.js';\nimport { PromiseQueue } from '../../util/PromiseQueue.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport 'cross-fetch';\nimport PKCE from '../util/pkce.js';\nimport { createTokenAPI, createEndpoints } from '../factory/api.js';\nimport { TokenManager } from '../TokenManager.js';\nimport { getOAuthUrls } from '../util/oauth.js';\nimport { isLoginRedirect } from '../util/loginRedirect.js';\nimport '../types/Token.js';\nimport { provideOriginalUri } from './browser.js';\nfunction mixinOAuth(Base, TransactionManagerConstructor) {\n  var _a;\n  const WithOriginalUri = provideOriginalUri(Base);\n  return _a = class OktaAuthOAuth extends WithOriginalUri {\n    constructor(...args) {\n      super(...args);\n      this.transactionManager = new TransactionManagerConstructor(Object.assign({\n        storageManager: this.storageManager\n      }, this.options.transactionManager));\n      this.pkce = {\n        DEFAULT_CODE_CHALLENGE_METHOD: PKCE.DEFAULT_CODE_CHALLENGE_METHOD,\n        generateVerifier: PKCE.generateVerifier,\n        computeChallenge: PKCE.computeChallenge\n      };\n      this._pending = {\n        handleLogin: false\n      };\n      this._tokenQueue = new PromiseQueue();\n      this.token = createTokenAPI(this, this._tokenQueue);\n      this.tokenManager = new TokenManager(this, this.options.tokenManager);\n      this.endpoints = createEndpoints(this);\n    }\n    clearStorage() {\n      super.clearStorage();\n      this.tokenManager.clear();\n    }\n    async isAuthenticated(options = {}) {\n      const {\n        autoRenew,\n        autoRemove\n      } = this.tokenManager.getOptions();\n      const shouldRenew = options.onExpiredToken ? options.onExpiredToken === 'renew' : autoRenew;\n      const shouldRemove = options.onExpiredToken ? options.onExpiredToken === 'remove' : autoRemove;\n      let {\n        accessToken\n      } = this.tokenManager.getTokensSync();\n      if (accessToken && this.tokenManager.hasExpired(accessToken)) {\n        accessToken = undefined;\n        if (shouldRenew) {\n          try {\n            accessToken = await this.tokenManager.renew('accessToken');\n          } catch (_a) {}\n        } else if (shouldRemove) {\n          this.tokenManager.remove('accessToken');\n        }\n      }\n      let {\n        idToken\n      } = this.tokenManager.getTokensSync();\n      if (idToken && this.tokenManager.hasExpired(idToken)) {\n        idToken = undefined;\n        if (shouldRenew) {\n          try {\n            idToken = await this.tokenManager.renew('idToken');\n          } catch (_b) {}\n        } else if (shouldRemove) {\n          this.tokenManager.remove('idToken');\n        }\n      }\n      return !!(accessToken && idToken);\n    }\n    async signInWithRedirect(opts = {}) {\n      const {\n          originalUri\n        } = opts,\n        additionalParams = __rest(opts, [\"originalUri\"]);\n      if (this._pending.handleLogin) {\n        return;\n      }\n      this._pending.handleLogin = true;\n      try {\n        if (originalUri) {\n          this.setOriginalUri(originalUri);\n        }\n        const params = Object.assign({\n          scopes: this.options.scopes || ['openid', 'email', 'profile']\n        }, additionalParams);\n        await this.token.getWithRedirect(params);\n      } finally {\n        this._pending.handleLogin = false;\n      }\n    }\n    async getUser() {\n      const {\n        idToken,\n        accessToken\n      } = this.tokenManager.getTokensSync();\n      return this.token.getUserInfo(accessToken, idToken);\n    }\n    getIdToken() {\n      const {\n        idToken\n      } = this.tokenManager.getTokensSync();\n      return idToken ? idToken.idToken : undefined;\n    }\n    getAccessToken() {\n      const {\n        accessToken\n      } = this.tokenManager.getTokensSync();\n      return accessToken ? accessToken.accessToken : undefined;\n    }\n    getRefreshToken() {\n      const {\n        refreshToken\n      } = this.tokenManager.getTokensSync();\n      return refreshToken ? refreshToken.refreshToken : undefined;\n    }\n    async storeTokensFromRedirect() {\n      const {\n        tokens,\n        responseType\n      } = await this.token.parseFromUrl();\n      if (responseType !== 'none') {\n        this.tokenManager.setTokens(tokens);\n      }\n    }\n    isLoginRedirect() {\n      return isLoginRedirect(this);\n    }\n    isPKCE() {\n      return !!this.options.pkce;\n    }\n    hasResponseType(responseType) {\n      let hasResponseType = false;\n      if (Array.isArray(this.options.responseType) && this.options.responseType.length) {\n        hasResponseType = this.options.responseType.indexOf(responseType) >= 0;\n      } else {\n        hasResponseType = this.options.responseType === responseType;\n      }\n      return hasResponseType;\n    }\n    isAuthorizationCodeFlow() {\n      return this.hasResponseType('code');\n    }\n    async invokeApiMethod(options) {\n      if (!options.accessToken) {\n        const accessToken = (await this.tokenManager.getTokens()).accessToken;\n        options.accessToken = accessToken === null || accessToken === void 0 ? void 0 : accessToken.accessToken;\n      }\n      return httpRequest(this, options);\n    }\n    async revokeAccessToken(accessToken) {\n      if (!accessToken) {\n        accessToken = (await this.tokenManager.getTokens()).accessToken;\n        const accessTokenKey = this.tokenManager.getStorageKeyByType('accessToken');\n        this.tokenManager.remove(accessTokenKey);\n      }\n      if (!accessToken) {\n        return Promise.resolve(null);\n      }\n      return this.token.revoke(accessToken);\n    }\n    async revokeRefreshToken(refreshToken) {\n      if (!refreshToken) {\n        refreshToken = (await this.tokenManager.getTokens()).refreshToken;\n        const refreshTokenKey = this.tokenManager.getStorageKeyByType('refreshToken');\n        this.tokenManager.remove(refreshTokenKey);\n      }\n      if (!refreshToken) {\n        return Promise.resolve(null);\n      }\n      return this.token.revoke(refreshToken);\n    }\n    getSignOutRedirectUrl(options = {}) {\n      let {\n        idToken,\n        postLogoutRedirectUri,\n        state\n      } = options;\n      if (!idToken) {\n        idToken = this.tokenManager.getTokensSync().idToken;\n      }\n      if (!idToken) {\n        return '';\n      }\n      if (postLogoutRedirectUri === undefined) {\n        postLogoutRedirectUri = this.options.postLogoutRedirectUri;\n      }\n      const logoutUrl = getOAuthUrls(this).logoutUrl;\n      const idTokenHint = idToken.idToken;\n      let logoutUri = logoutUrl + '?id_token_hint=' + encodeURIComponent(idTokenHint);\n      if (postLogoutRedirectUri) {\n        logoutUri += '&post_logout_redirect_uri=' + encodeURIComponent(postLogoutRedirectUri);\n      }\n      if (state) {\n        logoutUri += '&state=' + encodeURIComponent(state);\n      }\n      return logoutUri;\n    }\n    async signOut(options) {\n      options = Object.assign({}, options);\n      const defaultUri = window.location.origin;\n      const currentUri = window.location.href;\n      const postLogoutRedirectUri = options.postLogoutRedirectUri === null ? null : options.postLogoutRedirectUri || this.options.postLogoutRedirectUri || defaultUri;\n      const state = options === null || options === void 0 ? void 0 : options.state;\n      let accessToken = options.accessToken;\n      let refreshToken = options.refreshToken;\n      const revokeAccessToken = options.revokeAccessToken !== false;\n      const revokeRefreshToken = options.revokeRefreshToken !== false;\n      if (revokeRefreshToken && typeof refreshToken === 'undefined') {\n        refreshToken = this.tokenManager.getTokensSync().refreshToken;\n      }\n      if (revokeAccessToken && typeof accessToken === 'undefined') {\n        accessToken = this.tokenManager.getTokensSync().accessToken;\n      }\n      if (!options.idToken) {\n        options.idToken = this.tokenManager.getTokensSync().idToken;\n      }\n      if (revokeRefreshToken && refreshToken) {\n        await this.revokeRefreshToken(refreshToken);\n      }\n      if (revokeAccessToken && accessToken) {\n        await this.revokeAccessToken(accessToken);\n      }\n      const logoutUri = this.getSignOutRedirectUrl(Object.assign(Object.assign({}, options), {\n        postLogoutRedirectUri\n      }));\n      if (!logoutUri) {\n        const sessionClosed = await this.closeSession();\n        const redirectUri = new URL(postLogoutRedirectUri || defaultUri);\n        if (state) {\n          redirectUri.searchParams.append('state', state);\n        }\n        if (postLogoutRedirectUri === currentUri) {\n          window.location.href = redirectUri.href;\n        } else {\n          window.location.assign(redirectUri.href);\n        }\n        return sessionClosed;\n      } else {\n        if (options.clearTokensBeforeRedirect) {\n          this.tokenManager.clear();\n        } else {\n          this.tokenManager.addPendingRemoveFlags();\n        }\n        window.location.assign(logoutUri);\n        return true;\n      }\n    }\n  }, _a.crypto = index, _a;\n}\nexport { mixinOAuth };","map":{"version":3,"names":["mixinOAuth","Base","TransactionManagerConstructor","WithOriginalUri","provideOriginalUri","_a","OktaAuthOAuth","constructor","args","transactionManager","Object","assign","storageManager","options","pkce","DEFAULT_CODE_CHALLENGE_METHOD","PKCE","generateVerifier","computeChallenge","_pending","handleLogin","_tokenQueue","PromiseQueue","token","createTokenAPI","tokenManager","TokenManager","endpoints","createEndpoints","clearStorage","clear","isAuthenticated","autoRenew","autoRemove","getOptions","shouldRenew","onExpiredToken","shouldRemove","accessToken","getTokensSync","hasExpired","undefined","renew","remove","idToken","_b","signInWithRedirect","opts","originalUri","additionalParams","__rest","setOriginalUri","params","scopes","getWithRedirect","getUser","getUserInfo","getIdToken","getAccessToken","getRefreshToken","refreshToken","storeTokensFromRedirect","tokens","responseType","parseFromUrl","setTokens","isLoginRedirect","isPKCE","hasResponseType","Array","isArray","length","indexOf","isAuthorizationCodeFlow","invokeApiMethod","getTokens","httpRequest","revokeAccessToken","accessTokenKey","getStorageKeyByType","Promise","resolve","revoke","revokeRefreshToken","refreshTokenKey","getSignOutRedirectUrl","postLogoutRedirectUri","state","logoutUrl","getOAuthUrls","idTokenHint","logoutUri","encodeURIComponent","signOut","defaultUri","window","location","origin","currentUri","href","sessionClosed","closeSession","redirectUri","URL","searchParams","append","clearTokensBeforeRedirect","addPendingRemoveFlags","crypto","index"],"sources":["/Users/aadar00/Documents/image-moderation-app/frontend/node_modules/@okta/lib/oidc/mixin/index.ts"],"sourcesContent":["import { httpRequest, RequestOptions } from '../../http';\nimport { OktaAuthConstructor } from '../../base/types';\nimport { \n  PromiseQueue,\n} from '../../util';\nimport { CryptoAPI } from '../../crypto/types';\nimport * as crypto from '../../crypto';\nimport {\n  AccessToken,\n  CustomUserClaims,\n  IDToken,\n  IsAuthenticatedOptions,\n  OAuthResponseType,\n  OAuthStorageManagerInterface,\n  OAuthTransactionMeta,\n  OktaAuthOAuthInterface,\n  OktaAuthOAuthOptions,\n  PkceAPI,\n  PKCETransactionMeta,\n  RefreshToken,\n  SigninWithRedirectOptions,\n  SignoutOptions,\n  SignoutRedirectUrlOptions,\n  TokenAPI,\n  TransactionManagerInterface,\n  TransactionManagerConstructor,\n  UserClaims,\n  Endpoints,\n} from '../types';\nimport PKCE from '../util/pkce';\nimport { createEndpoints, createTokenAPI } from '../factory';\nimport { TokenManager } from '../TokenManager';\nimport { getOAuthUrls, isLoginRedirect } from '../util';\n\nimport { OktaAuthSessionInterface } from '../../session/types';\nimport { provideOriginalUri } from './node';\nexport function mixinOAuth\n<\n  M extends OAuthTransactionMeta = PKCETransactionMeta,\n  S extends OAuthStorageManagerInterface<M> = OAuthStorageManagerInterface<M>,\n  O extends OktaAuthOAuthOptions = OktaAuthOAuthOptions,\n  TM extends TransactionManagerInterface = TransactionManagerInterface,\n  TBase extends OktaAuthConstructor<OktaAuthSessionInterface<S, O>>\n    = OktaAuthConstructor<OktaAuthSessionInterface<S, O>>\n>\n(\n  Base: TBase,\n  TransactionManagerConstructor: TransactionManagerConstructor<TM>,\n): TBase & OktaAuthConstructor<OktaAuthOAuthInterface<M, S, O, TM>>\n{\n  const WithOriginalUri = provideOriginalUri(Base);\n  return class OktaAuthOAuth extends WithOriginalUri\n  implements OktaAuthOAuthInterface<M, S, O, TM>\n  {\n    static crypto: CryptoAPI = crypto;\n    token: TokenAPI;\n    tokenManager: TokenManager;\n    transactionManager: TM;\n    pkce: PkceAPI;\n    endpoints: Endpoints;\n\n    _pending: { handleLogin: boolean };\n    _tokenQueue: PromiseQueue;\n    \n    constructor(...args: any[]) {\n      super(...args);\n\n      this.transactionManager = new TransactionManagerConstructor(Object.assign({\n        storageManager: this.storageManager,\n      }, this.options.transactionManager));\n  \n      this.pkce = {\n        DEFAULT_CODE_CHALLENGE_METHOD: PKCE.DEFAULT_CODE_CHALLENGE_METHOD,\n        generateVerifier: PKCE.generateVerifier,\n        computeChallenge: PKCE.computeChallenge\n      };\n  \n      this._pending = { handleLogin: false };\n\n      this._tokenQueue = new PromiseQueue();\n\n      this.token = createTokenAPI(this, this._tokenQueue);\n\n      // TokenManager\n      this.tokenManager = new TokenManager(this, this.options.tokenManager);\n\n      this.endpoints = createEndpoints(this);\n    }\n\n    // inherited from subclass\n    clearStorage(): void {\n      super.clearStorage();\n      \n      // Clear all local tokens\n      this.tokenManager.clear();\n    }\n\n    // Returns true if both accessToken and idToken are not expired\n    // If `autoRenew` option is set, will attempt to renew expired tokens before returning.\n    // eslint-disable-next-line complexity\n    async isAuthenticated(options: IsAuthenticatedOptions = {}): Promise<boolean> {\n      // TODO: remove dependency on tokenManager options in next major version - OKTA-473815\n      const { autoRenew, autoRemove } = this.tokenManager.getOptions();\n\n      const shouldRenew = options.onExpiredToken ? options.onExpiredToken === 'renew' : autoRenew;\n      const shouldRemove = options.onExpiredToken ? options.onExpiredToken === 'remove' : autoRemove;\n\n      let { accessToken } = this.tokenManager.getTokensSync();\n      if (accessToken && this.tokenManager.hasExpired(accessToken)) {\n        accessToken = undefined;\n        if (shouldRenew) {\n          try {\n            accessToken = await this.tokenManager.renew('accessToken') as AccessToken;\n          } catch {\n            // Renew errors will emit an \"error\" event \n          }\n        } else if (shouldRemove) {\n          this.tokenManager.remove('accessToken');\n        }\n      }\n\n      let { idToken } = this.tokenManager.getTokensSync();\n      if (idToken && this.tokenManager.hasExpired(idToken)) {\n        idToken = undefined;\n        if (shouldRenew) {\n          try {\n            idToken = await this.tokenManager.renew('idToken') as IDToken;\n          } catch {\n            // Renew errors will emit an \"error\" event \n          }\n        } else if (shouldRemove) {\n          this.tokenManager.remove('idToken');\n        }\n      }\n\n      return !!(accessToken && idToken);\n    }\n\n\n    async signInWithRedirect(opts: SigninWithRedirectOptions = {}) {\n      const { originalUri, ...additionalParams } = opts;\n      if(this._pending.handleLogin) { \n        // Don't trigger second round\n        return;\n      }\n\n      this._pending.handleLogin = true;\n      try {\n        // Trigger default signIn redirect flow\n        if (originalUri) {\n          this.setOriginalUri(originalUri);\n        }\n        const params = Object.assign({\n          // TODO: remove this line when default scopes are changed OKTA-343294\n          scopes: this.options.scopes || ['openid', 'email', 'profile']\n        }, additionalParams);\n        await this.token.getWithRedirect(params);\n      } finally {\n        this._pending.handleLogin = false;\n      }\n    }\n\n    async getUser<T extends CustomUserClaims = CustomUserClaims>(): Promise<UserClaims<T>> {\n      const { idToken, accessToken } = this.tokenManager.getTokensSync();\n      return this.token.getUserInfo(accessToken, idToken);\n    }\n  \n    getIdToken(): string | undefined {\n      const { idToken } = this.tokenManager.getTokensSync();\n      return idToken ? idToken.idToken : undefined;\n    }\n  \n    getAccessToken(): string | undefined {\n      const { accessToken } = this.tokenManager.getTokensSync();\n      return accessToken ? accessToken.accessToken : undefined;\n    }\n  \n    getRefreshToken(): string | undefined {\n      const { refreshToken } = this.tokenManager.getTokensSync();\n      return refreshToken ? refreshToken.refreshToken : undefined;\n    }\n  \n    /**\n     * Store parsed tokens from redirect url\n     */\n    async storeTokensFromRedirect(): Promise<void> {\n      const { tokens, responseType } = await this.token.parseFromUrl();\n      if (responseType !== 'none') {\n        this.tokenManager.setTokens(tokens);\n      }\n    }\n  \n    isLoginRedirect(): boolean {\n      return isLoginRedirect(this);\n    }\n\n    isPKCE(): boolean {\n      return !!this.options.pkce;\n    }\n  \n    hasResponseType(responseType: OAuthResponseType): boolean {\n      let hasResponseType = false;\n      if (Array.isArray(this.options.responseType) && this.options.responseType.length) {\n        hasResponseType = this.options.responseType.indexOf(responseType) >= 0;\n      } else {\n        hasResponseType = this.options.responseType === responseType;\n      }\n      return hasResponseType;\n    }\n  \n    isAuthorizationCodeFlow(): boolean {\n      return this.hasResponseType('code');\n    }\n\n    // Escape hatch method to make arbitrary OKTA API call\n    async invokeApiMethod(options: RequestOptions): Promise<unknown> {\n      if (!options.accessToken) {\n        const accessToken = (await this.tokenManager.getTokens()).accessToken as AccessToken;\n        options.accessToken = accessToken?.accessToken;\n      }\n      return httpRequest(this, options);\n    }\n    \n    // Revokes the access token for the application session\n    async revokeAccessToken(accessToken?: AccessToken): Promise<unknown> {\n      if (!accessToken) {\n        accessToken = (await this.tokenManager.getTokens()).accessToken as AccessToken;\n        const accessTokenKey = this.tokenManager.getStorageKeyByType('accessToken');\n        this.tokenManager.remove(accessTokenKey);\n      }\n      // Access token may have been removed. In this case, we will silently succeed.\n      if (!accessToken) {\n        return Promise.resolve(null);\n      }\n      return this.token.revoke(accessToken);\n    }\n\n    // Revokes the refresh token for the application session\n    async revokeRefreshToken(refreshToken?: RefreshToken): Promise<unknown> {\n      if (!refreshToken) {\n        refreshToken = (await this.tokenManager.getTokens()).refreshToken as RefreshToken;\n        const refreshTokenKey = this.tokenManager.getStorageKeyByType('refreshToken');\n        this.tokenManager.remove(refreshTokenKey);\n      }\n      // Refresh token may have been removed. In this case, we will silently succeed.\n      if (!refreshToken) {\n        return Promise.resolve(null);\n      }\n      return this.token.revoke(refreshToken);\n    }\n\n    getSignOutRedirectUrl(options: SignoutRedirectUrlOptions = {}) {\n      let {\n        idToken,\n        postLogoutRedirectUri,\n        state,\n      } = options;\n      if (!idToken) {\n        idToken = this.tokenManager.getTokensSync().idToken as IDToken;\n      }\n      if (!idToken) {\n        return '';\n      }\n      if (postLogoutRedirectUri === undefined) {\n        postLogoutRedirectUri = this.options.postLogoutRedirectUri;\n      }\n\n      const logoutUrl = getOAuthUrls(this).logoutUrl;\n      const idTokenHint = idToken.idToken; // a string\n      let logoutUri = logoutUrl + '?id_token_hint=' + encodeURIComponent(idTokenHint);\n      if (postLogoutRedirectUri) {\n        logoutUri += '&post_logout_redirect_uri=' + encodeURIComponent(postLogoutRedirectUri);\n      } \n      // State allows option parameters to be passed to logout redirect uri\n      if (state) {\n        logoutUri += '&state=' + encodeURIComponent(state);\n      }\n\n      return logoutUri;\n    }\n\n    // Revokes refreshToken or accessToken, clears all local tokens, then redirects to Okta to end the SSO session.\n    // eslint-disable-next-line complexity, max-statements\n    async signOut(options?: SignoutOptions): Promise<boolean> {\n      options = Object.assign({}, options);\n    \n      // postLogoutRedirectUri must be whitelisted in Okta Admin UI\n      const defaultUri = window.location.origin;\n      const currentUri = window.location.href;\n      // Fix for issue/1410 - allow for no postLogoutRedirectUri to be passed, resulting in /logout default behavior\n      //    \"If no Okta session exists, this endpoint has no effect and the browser is redirected immediately to the\n      //    Okta sign-in page or the post_logout_redirect_uri (if specified).\"\n      // - https://developer.okta.com/docs/reference/api/oidc/#logout\n      const postLogoutRedirectUri = options.postLogoutRedirectUri === null ? null :\n        (options.postLogoutRedirectUri\n        || this.options.postLogoutRedirectUri\n        || defaultUri);\n      const state = options?.state;\n      \n    \n      let accessToken = options.accessToken;\n      let refreshToken = options.refreshToken;\n      const revokeAccessToken = options.revokeAccessToken !== false;\n      const revokeRefreshToken = options.revokeRefreshToken !== false;\n    \n      if (revokeRefreshToken && typeof refreshToken === 'undefined') {\n        refreshToken = this.tokenManager.getTokensSync().refreshToken as RefreshToken;\n      }\n\n      if (revokeAccessToken && typeof accessToken === 'undefined') {\n        accessToken = this.tokenManager.getTokensSync().accessToken as AccessToken;\n      }\n    \n      if (!options.idToken) {\n        options.idToken = this.tokenManager.getTokensSync().idToken as IDToken;\n      }\n\n      if (revokeRefreshToken && refreshToken) {\n        await this.revokeRefreshToken(refreshToken);\n      }\n\n      if (revokeAccessToken && accessToken) {\n        await this.revokeAccessToken(accessToken);\n      }\n\n      const logoutUri = this.getSignOutRedirectUrl({ ...options, postLogoutRedirectUri });\n      // No logoutUri? This can happen if the storage was cleared.\n      // Fallback to XHR signOut, then simulate a redirect to the post logout uri\n      if (!logoutUri) {\n        // local tokens are cleared once session is closed\n        const sessionClosed = await this.closeSession();   // can throw if the user cannot be signed out\n        const redirectUri = new URL(postLogoutRedirectUri || defaultUri); // during fallback, redirectUri cannot be null\n        if (state) {\n          redirectUri.searchParams.append('state', state);\n        }\n        if (postLogoutRedirectUri === currentUri) {\n          // window.location.reload(); // force a hard reload if URI is not changing\n          window.location.href = redirectUri.href;\n        } else {\n          window.location.assign(redirectUri.href);\n        }\n        return sessionClosed;\n      } else {\n        if (options.clearTokensBeforeRedirect) {\n          // Clear all local tokens\n          this.tokenManager.clear();\n        } else {\n          this.tokenManager.addPendingRemoveFlags();\n        }\n        // Flow ends with logout redirect\n        window.location.assign(logoutUri);\n        return true;\n      }\n    }\n\n  };\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}