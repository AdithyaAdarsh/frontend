{"ast":null,"code":"/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { getRequiredValues, getAllValues, titleCase, getAuthenticatorFromRemediation } from '../util.js';\nimport { formatAuthenticator, compareAuthenticators } from '../../authenticator/util.js';\nclass Remediator {\n  constructor(remediation, values = {}, options = {}) {\n    this.values = Object.assign({}, values);\n    this.options = Object.assign({}, options);\n    this.formatAuthenticators();\n    this.remediation = remediation;\n  }\n  formatAuthenticators() {\n    this.values.authenticators = this.values.authenticators || [];\n    this.values.authenticators = this.values.authenticators.map(authenticator => {\n      return formatAuthenticator(authenticator);\n    });\n    if (this.values.authenticator) {\n      const authenticator = formatAuthenticator(this.values.authenticator);\n      const hasAuthenticatorInList = this.values.authenticators.some(existing => {\n        return compareAuthenticators(authenticator, existing);\n      });\n      if (!hasAuthenticatorInList) {\n        this.values.authenticators.push(authenticator);\n      }\n    }\n    this.values.authenticatorsData = this.values.authenticators.reduce((acc, authenticator) => {\n      if (typeof authenticator === 'object' && Object.keys(authenticator).length > 1) {\n        acc.push(authenticator);\n      }\n      return acc;\n    }, this.values.authenticatorsData || []);\n  }\n  getName() {\n    return this.remediation.name;\n  }\n  canRemediate(context) {\n    const required = getRequiredValues(this.remediation);\n    const needed = required.find(key => !this.hasData(key));\n    if (needed) {\n      return false;\n    }\n    return true;\n  }\n  getData(key) {\n    if (!key) {\n      let allValues = getAllValues(this.remediation);\n      let res = allValues.reduce((data, key) => {\n        data[key] = this.getData(key);\n        return data;\n      }, {});\n      return res;\n    }\n    if (typeof this[`map${titleCase(key)}`] === 'function') {\n      const val = this[`map${titleCase(key)}`](this.remediation.value.find(({\n        name\n      }) => name === key));\n      if (val) {\n        return val;\n      }\n    }\n    if (this.map && this.map[key]) {\n      const entry = this.map[key];\n      for (let i = 0; i < entry.length; i++) {\n        let val = this.values[entry[i]];\n        if (val) {\n          return val;\n        }\n      }\n    }\n    return this.values[key];\n  }\n  hasData(key) {\n    return !!this.getData(key);\n  }\n  getNextStep(_authClient, _context) {\n    const name = this.getName();\n    const inputs = this.getInputs();\n    const authenticator = this.getAuthenticator();\n    const type = authenticator === null || authenticator === void 0 ? void 0 : authenticator.type;\n    return Object.assign(Object.assign({\n      name,\n      inputs\n    }, type && {\n      type\n    }), authenticator && {\n      authenticator\n    });\n  }\n  getInputs() {\n    const inputs = [];\n    const inputsFromRemediation = this.remediation.value || [];\n    inputsFromRemediation.forEach(inputFromRemediation => {\n      let input;\n      let {\n        name,\n        type,\n        visible,\n        messages\n      } = inputFromRemediation;\n      if (visible === false) {\n        return;\n      }\n      if (typeof this[`getInput${titleCase(name)}`] === 'function') {\n        input = this[`getInput${titleCase(name)}`](inputFromRemediation);\n      } else if (type !== 'object') {\n        let alias;\n        const aliases = (this.map ? this.map[name] : null) || [];\n        if (aliases.length === 1) {\n          alias = aliases[0];\n        } else {\n          alias = aliases.find(name => Object.keys(this.values).includes(name));\n        }\n        if (alias) {\n          input = Object.assign(Object.assign({}, inputFromRemediation), {\n            name: alias\n          });\n        }\n      }\n      if (!input) {\n        input = inputFromRemediation;\n      }\n      if (Array.isArray(input)) {\n        input.forEach(i => inputs.push(i));\n      } else {\n        if (messages) {\n          input.messages = messages;\n        }\n        inputs.push(input);\n      }\n    });\n    return inputs;\n  }\n  static getMessages(remediation) {\n    var _a, _b;\n    if (!remediation.value) {\n      return;\n    }\n    return (_b = (_a = remediation.value[0]) === null || _a === void 0 ? void 0 : _a.form) === null || _b === void 0 ? void 0 : _b.value.reduce((messages, field) => {\n      if (field.messages) {\n        messages = [...messages, ...field.messages.value];\n      }\n      return messages;\n    }, []);\n  }\n  getValuesAfterProceed() {\n    const inputsFromRemediation = this.remediation.value || [];\n    const inputsFromRemediator = this.getInputs();\n    const inputs = [...inputsFromRemediation, ...inputsFromRemediator];\n    for (const input of inputs) {\n      delete this.values[input.name];\n    }\n    return this.values;\n  }\n  getAuthenticator() {\n    var _a, _b;\n    const relatesTo = (_a = this.remediation.relatesTo) === null || _a === void 0 ? void 0 : _a.value;\n    if (!relatesTo) {\n      return;\n    }\n    const authenticatorFromRemediation = getAuthenticatorFromRemediation(this.remediation);\n    if (!authenticatorFromRemediation) {\n      return relatesTo;\n    }\n    const id = authenticatorFromRemediation.form.value.find(({\n      name\n    }) => name === 'id').value;\n    const enrollmentId = (_b = authenticatorFromRemediation.form.value.find(({\n      name\n    }) => name === 'enrollmentId')) === null || _b === void 0 ? void 0 : _b.value;\n    return Object.assign(Object.assign({}, relatesTo), {\n      id,\n      enrollmentId\n    });\n  }\n}\nexport { Remediator };","map":{"version":3,"names":["Remediator","constructor","remediation","values","options","Object","assign","formatAuthenticators","authenticators","map","authenticator","formatAuthenticator","hasAuthenticatorInList","some","existing","compareAuthenticators","push","authenticatorsData","reduce","acc","keys","length","getName","name","canRemediate","context","required","getRequiredValues","needed","find","key","hasData","getData","allValues","getAllValues","res","data","titleCase","val","value","entry","i","getNextStep","_authClient","_context","inputs","getInputs","getAuthenticator","type","inputsFromRemediation","forEach","inputFromRemediation","input","visible","messages","alias","aliases","includes","Array","isArray","getMessages","_b","_a","form","field","getValuesAfterProceed","inputsFromRemediator","relatesTo","authenticatorFromRemediation","getAuthenticatorFromRemediation","id","enrollmentId"],"sources":["/Users/aadar00/Library/CloudStorage/OneDrive-BlackhawkNetwork,Inc/Documents/image-moderation-app/frontend/node_modules/@okta/lib/idx/remediators/Base/Remediator.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\n\n/* eslint-disable complexity */\nimport { OktaAuthIdxInterface, NextStep, IdxMessage, Authenticator, Input, RemediateOptions } from '../../types';\nimport { IdxAuthenticator, IdxRemediation, IdxContext } from '../../types/idx-js';\nimport { getAllValues, getRequiredValues, titleCase, getAuthenticatorFromRemediation } from '../util';\nimport { formatAuthenticator, compareAuthenticators } from '../../authenticator/util';\n\n// A map from IDX data values (server spec) to RemediationValues (client spec)\nexport type IdxToRemediationValueMap = Record<string, string[]>;\n\nexport interface RemediationValues {\n  stateHandle?: string;\n  authenticators?: (Authenticator | string)[];\n  authenticator?: string | Authenticator;\n  authenticatorsData?: Authenticator[];\n  resend?: boolean;\n}\n\nexport interface RemediatorConstructor {\n  new<T extends RemediationValues>(\n    remediation: IdxRemediation, \n    values?: T, \n    options?: RemediateOptions\n  ): any;\n}\n\n// Base class - DO NOT expose static remediationName\nexport class Remediator<T extends RemediationValues = RemediationValues> {\n  static remediationName: string;\n\n  remediation: IdxRemediation;\n  values: T;\n  options: RemediateOptions;\n  map?: IdxToRemediationValueMap;\n\n  constructor(\n    remediation: IdxRemediation, \n    values: T = {} as T, \n    options: RemediateOptions = {}\n  ) {\n    // assign fields to the instance\n    this.values = { ...values };\n    this.options = { ...options };\n    this.formatAuthenticators();\n    this.remediation = remediation;\n  }\n\n  private formatAuthenticators() {\n    this.values.authenticators = (this.values.authenticators || []) as Authenticator[];\n\n    // ensure authenticators are in the correct format\n    this.values.authenticators = this.values.authenticators.map(authenticator => {\n      return formatAuthenticator(authenticator);\n    });\n\n    // add authenticator (if any) to \"authenticators\"\n    if (this.values.authenticator) {\n      const authenticator = formatAuthenticator(this.values.authenticator);\n      const hasAuthenticatorInList = this.values.authenticators.some(existing => {\n        return compareAuthenticators(authenticator, existing);\n      });\n      if (!hasAuthenticatorInList) {\n        this.values.authenticators.push(authenticator);\n      }\n    }\n\n    // save non-key meta to \"authenticatorsData\" field\n    // authenticators will be removed after selection to avoid select-authenticator loop\n    this.values.authenticatorsData = this.values.authenticators.reduce((acc, authenticator) => {\n      if (typeof authenticator === 'object' && Object.keys(authenticator).length > 1) {\n        // save authenticator meta into authenticator data\n        acc.push(authenticator);\n      }\n      return acc;\n    }, this.values.authenticatorsData || []);\n  }\n\n  getName(): string {\n    return this.remediation.name;\n  }\n\n  // Override this method to provide custom check\n  /* eslint-disable-next-line no-unused-vars, @typescript-eslint/no-unused-vars */\n  canRemediate(context?: IdxContext): boolean {\n    const required = getRequiredValues(this.remediation);\n    const needed = required!.find((key) => !this.hasData(key));\n    if (needed) {\n      return false; // missing data for a required field\n    }\n    return true; // all required fields have available data\n  }\n\n  // returns an object for the entire remediation form, or just a part\n  getData(key?: string) {\n    if (!key) {\n      let allValues = getAllValues(this.remediation);\n      let res = allValues!.reduce((data, key) => {\n        data[key] = this.getData(key); // recursive\n        return data;\n      }, {});\n      return res;\n    }\n\n    // Map value by \"map${Property}\" function in each subClass\n    if (typeof this[`map${titleCase(key)}`] === 'function') {\n      const val = this[`map${titleCase(key)}`](\n        this.remediation.value!.find(({name}) => name === key)\n      );\n      if (val) {\n        return val;\n      }\n    }\n\n    // If a map is defined for this key, return the first aliased property that returns a truthy value\n    if (this.map && this.map[key]) {\n      const entry = this.map[key];\n      for (let i = 0; i < entry.length; i++) {\n        let val = this.values[entry[i]];\n        if (val) {\n          return val;\n        }\n      }\n    }\n\n    // fallback: return the value by key\n    return this.values[key];\n  }\n\n  hasData(\n    key: string // idx name\n  ): boolean \n  {\n    // no attempt to format, we want simple true/false\n    return !!this.getData(key);\n  }\n\n  getNextStep(_authClient: OktaAuthIdxInterface, _context?: IdxContext): NextStep {\n    const name = this.getName();\n    const inputs = this.getInputs();\n    const authenticator = this.getAuthenticator();\n    // TODO: remove type field in the next major version change\n    // https://oktainc.atlassian.net/browse/OKTA-431749\n    const type = authenticator?.type;\n    return { \n      name, \n      inputs, \n      ...(type && { type }),\n      ...(authenticator && { authenticator }),\n    };\n  }\n\n  // Get inputs for the next step\n  getInputs(): Input[] {\n    const inputs: Input[] = [];\n    const inputsFromRemediation = this.remediation.value || [];\n    inputsFromRemediation.forEach(inputFromRemediation => {\n      let input;\n      let { name, type, visible, messages } = inputFromRemediation;\n      if (visible === false) {\n        return; // Filter out invisible inputs, like stateHandle\n      }\n      if (typeof this[`getInput${titleCase(name)}`] === 'function') {\n        input = this[`getInput${titleCase(name)}`](inputFromRemediation);\n      } else if (type !== 'object') {\n        // handle general primitive types\n        let alias;\n        const aliases = (this.map ? this.map[name] : null) || [];\n        if (aliases.length === 1) {\n          alias = aliases[0];\n        } else {\n          // try find key from values\n          alias = aliases.find(name => Object.keys(this.values).includes(name));\n        }\n        if (alias) {\n          input = { ...inputFromRemediation, name: alias };\n        }\n      }\n      if (!input) {\n        input = inputFromRemediation;\n      }\n      if (Array.isArray(input)) {\n        input.forEach(i => inputs.push(i));\n      } else {\n        // guarantees field-level messages are passed back\n        if (messages) {\n          input.messages = messages;\n        }\n        inputs.push(input);\n      }\n    });\n    return inputs;\n  }\n\n  static getMessages(remediation: IdxRemediation): IdxMessage[] | undefined {\n    if (!remediation.value) {\n      return;\n    }\n    return remediation.value[0]?.form?.value.reduce((messages: IdxMessage[], field) => {\n      if (field.messages) {\n        messages = [...messages, ...field.messages.value];\n      }\n      return messages;\n    }, []);\n  }\n\n  // Prepare values for the next remediation\n  // In general, remove used values from inputs for the current remediation\n  // Override this method if special cases need be handled\n  getValuesAfterProceed(): T {\n    const inputsFromRemediation = this.remediation.value || []; // \"raw\" inputs from server response\n    const inputsFromRemediator = this.getInputs(); // \"aliased\" inputs from SDK remediator\n    const inputs = [\n      ...inputsFromRemediation,\n      ...inputsFromRemediator\n    ];\n    // scrub all values related to this remediation\n    for (const input of inputs) {\n      delete this.values[input.name];\n    }\n    return this.values;\n  }\n\n  protected getAuthenticator(): IdxAuthenticator | undefined {\n    // relatesTo value may be an authenticator or an authenticatorEnrollment\n    const relatesTo = this.remediation.relatesTo?.value;\n    if (!relatesTo) {\n      return;\n    }\n\n    const authenticatorFromRemediation = getAuthenticatorFromRemediation(this.remediation);\n    if (!authenticatorFromRemediation) {\n      // Hopefully value is an authenticator\n      return relatesTo;\n    }\n\n    // If relatesTo is an authenticatorEnrollment, the id is actually the enrollmentId\n    // Let's get the correct authenticator id from the form value\n    const id = authenticatorFromRemediation.form!.value\n      .find(({ name }) => name === 'id')!.value as string;\n    const enrollmentId = authenticatorFromRemediation.form!.value\n      .find(({ name }) => name === 'enrollmentId')?.value as string;\n\n    return {\n      ...relatesTo,\n      id,\n      enrollmentId\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}