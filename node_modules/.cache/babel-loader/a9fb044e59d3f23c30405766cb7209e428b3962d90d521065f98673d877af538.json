{"ast":null,"code":"/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { removeNils, clone } from '../util/object.js';\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport { isLocalhost, isIE11OrLess } from '../features.js';\nimport { REFRESH_TOKEN_STORAGE_KEY, TOKEN_STORAGE_NAME } from '../constants.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport 'cross-fetch';\nimport { validateToken } from './util/validateToken.js';\nimport SdkClock from '../clock.js';\nimport { isRefreshToken, isAccessToken, isIDToken } from './types/Token.js';\nimport { EVENT_EXPIRED, EVENT_RENEWED, EVENT_ADDED, EVENT_REMOVED, EVENT_ERROR, EVENT_SET_STORAGE } from './types/TokenManager.js';\nconst DEFAULT_OPTIONS = {\n  autoRenew: true,\n  autoRemove: true,\n  syncStorage: true,\n  clearPendingRemoveTokens: true,\n  storage: undefined,\n  expireEarlySeconds: 30,\n  storageKey: TOKEN_STORAGE_NAME\n};\nfunction defaultState() {\n  return {\n    expireTimeouts: {},\n    renewPromise: null\n  };\n}\nclass TokenManager {\n  constructor(sdk, options = {}) {\n    this.sdk = sdk;\n    this.emitter = sdk.emitter;\n    if (!this.emitter) {\n      throw new AuthSdkError('Emitter should be initialized before TokenManager');\n    }\n    options = Object.assign({}, DEFAULT_OPTIONS, removeNils(options));\n    if (!isLocalhost()) {\n      options.expireEarlySeconds = DEFAULT_OPTIONS.expireEarlySeconds;\n    }\n    this.options = options;\n    const storageOptions = removeNils({\n      storageKey: options.storageKey,\n      secure: options.secure\n    });\n    if (typeof options.storage === 'object') {\n      storageOptions.storageProvider = options.storage;\n    } else if (options.storage) {\n      storageOptions.storageType = options.storage;\n    }\n    this.storage = sdk.storageManager.getTokenStorage(Object.assign(Object.assign({}, storageOptions), {\n      useSeparateCookies: true\n    }));\n    this.clock = SdkClock.create();\n    this.state = defaultState();\n  }\n  on(event, handler, context) {\n    if (context) {\n      this.emitter.on(event, handler, context);\n    } else {\n      this.emitter.on(event, handler);\n    }\n  }\n  off(event, handler) {\n    if (handler) {\n      this.emitter.off(event, handler);\n    } else {\n      this.emitter.off(event);\n    }\n  }\n  start() {\n    if (this.options.clearPendingRemoveTokens) {\n      this.clearPendingRemoveTokens();\n    }\n    this.setExpireEventTimeoutAll();\n    this.state.started = true;\n  }\n  stop() {\n    this.clearExpireEventTimeoutAll();\n    this.state.started = false;\n  }\n  isStarted() {\n    return !!this.state.started;\n  }\n  getOptions() {\n    return clone(this.options);\n  }\n  getExpireTime(token) {\n    const expireEarlySeconds = this.options.expireEarlySeconds || 0;\n    var expireTime = token.expiresAt - expireEarlySeconds;\n    return expireTime;\n  }\n  hasExpired(token) {\n    var expireTime = this.getExpireTime(token);\n    return expireTime <= this.clock.now();\n  }\n  emitExpired(key, token) {\n    this.emitter.emit(EVENT_EXPIRED, key, token);\n  }\n  emitRenewed(key, freshToken, oldToken) {\n    this.emitter.emit(EVENT_RENEWED, key, freshToken, oldToken);\n  }\n  emitAdded(key, token) {\n    this.emitter.emit(EVENT_ADDED, key, token);\n  }\n  emitRemoved(key, token) {\n    this.emitter.emit(EVENT_REMOVED, key, token);\n  }\n  emitError(error) {\n    this.emitter.emit(EVENT_ERROR, error);\n  }\n  clearExpireEventTimeout(key) {\n    clearTimeout(this.state.expireTimeouts[key]);\n    delete this.state.expireTimeouts[key];\n    this.state.renewPromise = null;\n  }\n  clearExpireEventTimeoutAll() {\n    var expireTimeouts = this.state.expireTimeouts;\n    for (var key in expireTimeouts) {\n      if (!Object.prototype.hasOwnProperty.call(expireTimeouts, key)) {\n        continue;\n      }\n      this.clearExpireEventTimeout(key);\n    }\n  }\n  setExpireEventTimeout(key, token) {\n    if (isRefreshToken(token)) {\n      return;\n    }\n    var expireTime = this.getExpireTime(token);\n    var expireEventWait = Math.max(expireTime - this.clock.now(), 0) * 1000;\n    this.clearExpireEventTimeout(key);\n    var expireEventTimeout = setTimeout(() => {\n      this.emitExpired(key, token);\n    }, expireEventWait);\n    this.state.expireTimeouts[key] = expireEventTimeout;\n  }\n  setExpireEventTimeoutAll() {\n    var tokenStorage = this.storage.getStorage();\n    for (var key in tokenStorage) {\n      if (!Object.prototype.hasOwnProperty.call(tokenStorage, key)) {\n        continue;\n      }\n      var token = tokenStorage[key];\n      this.setExpireEventTimeout(key, token);\n    }\n  }\n  resetExpireEventTimeoutAll() {\n    this.clearExpireEventTimeoutAll();\n    this.setExpireEventTimeoutAll();\n  }\n  add(key, token) {\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    this.emitAdded(key, token);\n    this.setExpireEventTimeout(key, token);\n  }\n  getSync(key) {\n    var tokenStorage = this.storage.getStorage();\n    return tokenStorage[key];\n  }\n  async get(key) {\n    return this.getSync(key);\n  }\n  getTokensSync() {\n    const tokens = {};\n    const tokenStorage = this.storage.getStorage();\n    Object.keys(tokenStorage).forEach(key => {\n      const token = tokenStorage[key];\n      if (isAccessToken(token)) {\n        tokens.accessToken = token;\n      } else if (isIDToken(token)) {\n        tokens.idToken = token;\n      } else if (isRefreshToken(token)) {\n        tokens.refreshToken = token;\n      }\n    });\n    return tokens;\n  }\n  async getTokens() {\n    return this.getTokensSync();\n  }\n  getStorageKeyByType(type) {\n    const tokenStorage = this.storage.getStorage();\n    const key = Object.keys(tokenStorage).filter(key => {\n      const token = tokenStorage[key];\n      return isAccessToken(token) && type === 'accessToken' || isIDToken(token) && type === 'idToken' || isRefreshToken(token) && type === 'refreshToken';\n    })[0];\n    return key;\n  }\n  getTokenType(token) {\n    if (isAccessToken(token)) {\n      return 'accessToken';\n    }\n    if (isIDToken(token)) {\n      return 'idToken';\n    }\n    if (isRefreshToken(token)) {\n      return 'refreshToken';\n    }\n    throw new AuthSdkError('Unknown token type');\n  }\n  emitSetStorageEvent() {\n    if (isIE11OrLess()) {\n      const storage = this.storage.getStorage();\n      this.emitter.emit(EVENT_SET_STORAGE, storage);\n    }\n  }\n  getStorage() {\n    return this.storage;\n  }\n  setTokens(tokens, accessTokenCb, idTokenCb, refreshTokenCb) {\n    const handleTokenCallback = (key, token) => {\n      const type = this.getTokenType(token);\n      if (type === 'accessToken') {\n        accessTokenCb && accessTokenCb(key, token);\n      } else if (type === 'idToken') {\n        idTokenCb && idTokenCb(key, token);\n      } else if (type === 'refreshToken') {\n        refreshTokenCb && refreshTokenCb(key, token);\n      }\n    };\n    const handleAdded = (key, token) => {\n      this.emitAdded(key, token);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n    const handleRenewed = (key, token, oldToken) => {\n      this.emitRenewed(key, token, oldToken);\n      this.clearExpireEventTimeout(key);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n    const handleRemoved = (key, token) => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, token);\n      handleTokenCallback(key, token);\n    };\n    const types = ['idToken', 'accessToken', 'refreshToken'];\n    const existingTokens = this.getTokensSync();\n    types.forEach(type => {\n      const token = tokens[type];\n      if (token) {\n        validateToken(token, type);\n      }\n    });\n    const storage = types.reduce((storage, type) => {\n      const token = tokens[type];\n      if (token) {\n        const storageKey = this.getStorageKeyByType(type) || type;\n        storage[storageKey] = token;\n      }\n      return storage;\n    }, {});\n    this.storage.setStorage(storage);\n    this.emitSetStorageEvent();\n    types.forEach(type => {\n      const newToken = tokens[type];\n      const existingToken = existingTokens[type];\n      const storageKey = this.getStorageKeyByType(type) || type;\n      if (newToken && existingToken) {\n        handleRemoved(storageKey, existingToken);\n        handleAdded(storageKey, newToken);\n        handleRenewed(storageKey, newToken, existingToken);\n      } else if (newToken) {\n        handleAdded(storageKey, newToken);\n      } else if (existingToken) {\n        handleRemoved(storageKey, existingToken);\n      }\n    });\n  }\n  remove(key) {\n    this.clearExpireEventTimeout(key);\n    var tokenStorage = this.storage.getStorage();\n    var removedToken = tokenStorage[key];\n    delete tokenStorage[key];\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    this.emitRemoved(key, removedToken);\n  }\n  async renewToken(token) {\n    var _a;\n    return (_a = this.sdk.token) === null || _a === void 0 ? void 0 : _a.renew(token);\n  }\n  validateToken(token) {\n    return validateToken(token);\n  }\n  renew(key) {\n    if (this.state.renewPromise) {\n      return this.state.renewPromise;\n    }\n    try {\n      var token = this.getSync(key);\n      if (!token) {\n        throw new AuthSdkError('The tokenManager has no token for the key: ' + key);\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n    this.clearExpireEventTimeout(key);\n    const renewPromise = this.state.renewPromise = this.sdk.token.renewTokens().then(tokens => {\n      this.setTokens(tokens);\n      const tokenType = this.getTokenType(token);\n      return tokens[tokenType];\n    }).catch(err => {\n      this.remove(key);\n      err.tokenKey = key;\n      this.emitError(err);\n      throw err;\n    }).finally(() => {\n      this.state.renewPromise = null;\n    });\n    return renewPromise;\n  }\n  clear() {\n    const tokens = this.getTokensSync();\n    this.clearExpireEventTimeoutAll();\n    this.storage.clearStorage();\n    this.emitSetStorageEvent();\n    Object.keys(tokens).forEach(key => {\n      this.emitRemoved(key, tokens[key]);\n    });\n  }\n  clearPendingRemoveTokens() {\n    const tokenStorage = this.storage.getStorage();\n    const removedTokens = {};\n    Object.keys(tokenStorage).forEach(key => {\n      if (tokenStorage[key].pendingRemove) {\n        removedTokens[key] = tokenStorage[key];\n        delete tokenStorage[key];\n      }\n    });\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    Object.keys(removedTokens).forEach(key => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, removedTokens[key]);\n    });\n  }\n  updateRefreshToken(token) {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n  }\n  removeRefreshToken() {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n    this.remove(key);\n  }\n  addPendingRemoveFlags() {\n    const tokens = this.getTokensSync();\n    Object.keys(tokens).forEach(key => {\n      tokens[key].pendingRemove = true;\n    });\n    this.setTokens(tokens);\n  }\n}\nexport { TokenManager };","map":{"version":3,"names":["DEFAULT_OPTIONS","autoRenew","autoRemove","syncStorage","clearPendingRemoveTokens","storage","undefined","expireEarlySeconds","storageKey","TOKEN_STORAGE_NAME","defaultState","expireTimeouts","renewPromise","TokenManager","constructor","sdk","options","emitter","AuthSdkError","Object","assign","removeNils","isLocalhost","storageOptions","secure","storageProvider","storageType","storageManager","getTokenStorage","useSeparateCookies","clock","SdkClock","create","state","on","event","handler","context","off","start","setExpireEventTimeoutAll","started","stop","clearExpireEventTimeoutAll","isStarted","getOptions","clone","getExpireTime","token","expireTime","expiresAt","hasExpired","now","emitExpired","key","emit","EVENT_EXPIRED","emitRenewed","freshToken","oldToken","EVENT_RENEWED","emitAdded","EVENT_ADDED","emitRemoved","EVENT_REMOVED","emitError","error","EVENT_ERROR","clearExpireEventTimeout","clearTimeout","prototype","hasOwnProperty","call","setExpireEventTimeout","isRefreshToken","expireEventWait","Math","max","expireEventTimeout","setTimeout","tokenStorage","getStorage","resetExpireEventTimeoutAll","add","validateToken","setStorage","emitSetStorageEvent","getSync","get","getTokensSync","tokens","keys","forEach","isAccessToken","accessToken","isIDToken","idToken","refreshToken","getTokens","getStorageKeyByType","type","filter","getTokenType","isIE11OrLess","EVENT_SET_STORAGE","setTokens","accessTokenCb","idTokenCb","refreshTokenCb","handleTokenCallback","handleAdded","handleRenewed","handleRemoved","types","existingTokens","reduce","newToken","existingToken","remove","removedToken","renewToken","_a","renew","e","Promise","reject","renewTokens","then","tokenType","catch","err","tokenKey","finally","clear","clearStorage","removedTokens","pendingRemove","updateRefreshToken","REFRESH_TOKEN_STORAGE_KEY","removeRefreshToken","addPendingRemoveFlags"],"sources":["/Users/aadar00/Documents/image-moderation-app/frontend/node_modules/@okta/lib/oidc/TokenManager.ts"],"sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n *\n */\nimport { removeNils, clone } from '../util';\nimport { AuthSdkError } from '../errors';\nimport { validateToken  } from '../oidc/util';\nimport { isLocalhost, isIE11OrLess } from '../features';\nimport SdkClock from '../clock';\nimport {\n  Token, \n  Tokens, \n  TokenType, \n  TokenManagerOptions, \n  isIDToken, \n  isAccessToken,\n  isRefreshToken,\n  TokenManagerErrorEventHandler,\n  TokenManagerSetStorageEventHandler,\n  TokenManagerRenewEventHandler,\n  TokenManagerEventHandler,\n  TokenManagerInterface,\n  RefreshToken,\n  AccessTokenCallback,\n  IDTokenCallback,\n  RefreshTokenCallback,\n  EVENT_RENEWED,\n  EVENT_ADDED,\n  EVENT_ERROR,\n  EVENT_EXPIRED,\n  EVENT_REMOVED,\n  EVENT_SET_STORAGE,\n  TokenManagerAnyEventHandler,\n  TokenManagerAnyEvent,\n  OktaAuthOAuthInterface\n} from './types';\nimport { REFRESH_TOKEN_STORAGE_KEY, TOKEN_STORAGE_NAME } from '../constants';\nimport { EventEmitter } from '../base/types';\nimport { StorageOptions, StorageProvider, StorageType } from '../storage/types';\n\nconst DEFAULT_OPTIONS = {\n  // TODO: remove in next major version - OKTA-473815\n  autoRenew: true,\n  autoRemove: true,\n  syncStorage: true,\n  // --- //\n  clearPendingRemoveTokens: true,\n  storage: undefined, // will use value from storageManager config\n  expireEarlySeconds: 30,\n  storageKey: TOKEN_STORAGE_NAME\n};\n\ninterface TokenManagerState {\n  expireTimeouts: Record<string, unknown>;\n  renewPromise: Promise<Token | undefined> | null;\n  started?: boolean;\n}\nfunction defaultState(): TokenManagerState {\n  return {\n    expireTimeouts: {},\n    renewPromise: null\n  };\n}\nexport class TokenManager implements TokenManagerInterface {\n  private sdk: OktaAuthOAuthInterface;\n  private clock: SdkClock;\n  private emitter: EventEmitter;\n  private storage: StorageProvider;\n  private state: TokenManagerState;\n  private options: TokenManagerOptions;\n\n  on(event: typeof EVENT_RENEWED, handler: TokenManagerRenewEventHandler, context?: object): void;\n  on(event: typeof EVENT_ERROR, handler: TokenManagerErrorEventHandler, context?: object): void;\n  on(event: typeof EVENT_SET_STORAGE, handler: TokenManagerSetStorageEventHandler, context?: object): void;\n  on(event: typeof EVENT_EXPIRED | typeof EVENT_ADDED | typeof EVENT_REMOVED, \n    handler: TokenManagerEventHandler, context?: object): void;\n  on(event: TokenManagerAnyEvent, handler: TokenManagerAnyEventHandler, context?: object): void {\n    if (context) {\n      this.emitter.on(event, handler, context);\n    } else {\n      this.emitter.on(event, handler);\n    }\n  }\n\n  off(event: typeof EVENT_RENEWED, handler?: TokenManagerRenewEventHandler): void;\n  off(event: typeof EVENT_ERROR, handler?: TokenManagerErrorEventHandler): void;\n  off(event: typeof EVENT_SET_STORAGE, handler?: TokenManagerSetStorageEventHandler): void;\n  off(event: typeof EVENT_EXPIRED | typeof EVENT_ADDED | typeof EVENT_REMOVED, \n    handler?: TokenManagerEventHandler): void;\n  off(event: TokenManagerAnyEvent, handler?: TokenManagerAnyEventHandler): void {\n    if (handler) {\n      this.emitter.off(event, handler);\n    } else {\n      this.emitter.off(event);\n    }\n  }\n\n  // eslint-disable-next-line complexity\n  constructor(sdk: OktaAuthOAuthInterface, options: TokenManagerOptions = {}) {\n    this.sdk = sdk;\n    this.emitter = (sdk as any).emitter;\n    if (!this.emitter) {\n      throw new AuthSdkError('Emitter should be initialized before TokenManager');\n    }\n    \n    options = Object.assign({}, DEFAULT_OPTIONS, removeNils(options));\n    if (!isLocalhost()) {\n      options.expireEarlySeconds = DEFAULT_OPTIONS.expireEarlySeconds;\n    }\n\n    this.options = options;\n\n    const storageOptions: StorageOptions = removeNils({\n      storageKey: options.storageKey,\n      secure: options.secure,\n    });\n    if (typeof options.storage === 'object') {\n      // A custom storage provider must implement getItem(key) and setItem(key, val)\n      storageOptions.storageProvider = options.storage;\n    } else if (options.storage) {\n      storageOptions.storageType = options.storage as StorageType;\n    }\n\n    this.storage = sdk.storageManager.getTokenStorage({...storageOptions, useSeparateCookies: true});\n    this.clock = SdkClock.create(/* sdk, options */);\n    this.state = defaultState();\n  }\n\n  start() {\n    if (this.options.clearPendingRemoveTokens) {\n      this.clearPendingRemoveTokens();\n    }\n    this.setExpireEventTimeoutAll();\n    this.state.started = true;\n  }\n  \n  stop() {\n    this.clearExpireEventTimeoutAll();\n    this.state.started = false;\n  }\n\n  isStarted() {\n    return !!this.state.started;\n  }\n\n  getOptions(): TokenManagerOptions {\n    return clone(this.options);\n  }\n  \n  getExpireTime(token) {\n    const expireEarlySeconds = this.options.expireEarlySeconds || 0;\n    var expireTime = token.expiresAt - expireEarlySeconds;\n    return expireTime;\n  }\n  \n  hasExpired(token) {\n    var expireTime = this.getExpireTime(token);\n    return expireTime <= this.clock.now();\n  }\n  \n  emitExpired(key, token) {\n    this.emitter.emit(EVENT_EXPIRED, key, token);\n  }\n  \n  emitRenewed(key, freshToken, oldToken) {\n    this.emitter.emit(EVENT_RENEWED, key, freshToken, oldToken);\n  }\n  \n  emitAdded(key, token) {\n    this.emitter.emit(EVENT_ADDED, key, token);\n  }\n  \n  emitRemoved(key, token?) {\n    this.emitter.emit(EVENT_REMOVED, key, token);\n  }\n  \n  emitError(error) {\n    this.emitter.emit(EVENT_ERROR, error);\n  }\n  \n  clearExpireEventTimeout(key) {\n    clearTimeout(this.state.expireTimeouts[key] as any);\n    delete this.state.expireTimeouts[key];\n  \n    // Remove the renew promise (if it exists)\n    this.state.renewPromise = null;\n  }\n  \n  clearExpireEventTimeoutAll() {\n    var expireTimeouts = this.state.expireTimeouts;\n    for (var key in expireTimeouts) {\n      if (!Object.prototype.hasOwnProperty.call(expireTimeouts, key)) {\n        continue;\n      }\n      this.clearExpireEventTimeout(key);\n    }\n  }\n  \n  setExpireEventTimeout(key, token) {\n    if (isRefreshToken(token)) {\n      return;\n    }\n\n    var expireTime = this.getExpireTime(token);\n    var expireEventWait = Math.max(expireTime - this.clock.now(), 0) * 1000;\n  \n    // Clear any existing timeout\n    this.clearExpireEventTimeout(key);\n  \n    var expireEventTimeout = setTimeout(() => {\n      this.emitExpired(key, token);\n    }, expireEventWait);\n  \n    // Add a new timeout\n    this.state.expireTimeouts[key] = expireEventTimeout;\n  }\n  \n  setExpireEventTimeoutAll() {\n    var tokenStorage = this.storage.getStorage();\n    for(var key in tokenStorage) {\n      if (!Object.prototype.hasOwnProperty.call(tokenStorage, key)) {\n        continue;\n      }\n      var token = tokenStorage[key];\n      this.setExpireEventTimeout(key, token);\n    }\n  }\n  \n  // reset timeouts to setup autoRenew for tokens from other document context (tabs)\n  resetExpireEventTimeoutAll() {\n    this.clearExpireEventTimeoutAll();\n    this.setExpireEventTimeoutAll();\n  }\n  \n  add(key, token: Token) {\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    this.emitAdded(key, token);\n    this.setExpireEventTimeout(key, token);\n  }\n  \n  getSync(key): Token | undefined {\n    var tokenStorage = this.storage.getStorage();\n    return tokenStorage[key];\n  }\n  \n  async get(key): Promise<Token | undefined> {\n    return this.getSync(key);\n  }\n  \n  getTokensSync(): Tokens {\n    const tokens = {} as Tokens;\n    const tokenStorage = this.storage.getStorage();\n    Object.keys(tokenStorage).forEach(key => {\n      const token = tokenStorage[key];\n      if (isAccessToken(token)) {\n        tokens.accessToken = token;\n      } else if (isIDToken(token)) {\n        tokens.idToken = token;\n      } else if (isRefreshToken(token)) { \n        tokens.refreshToken = token;\n      }\n    });\n    return tokens;\n  }\n  \n  async getTokens(): Promise<Tokens> {\n    return this.getTokensSync();\n  }\n\n  getStorageKeyByType(type: TokenType): string {\n    const tokenStorage = this.storage.getStorage();\n    const key = Object.keys(tokenStorage).filter(key => {\n      const token = tokenStorage[key];\n      return (isAccessToken(token) && type === 'accessToken') \n        || (isIDToken(token) && type === 'idToken')\n        || (isRefreshToken(token) && type === 'refreshToken');\n    })[0];\n    return key;\n  }\n\n  private getTokenType(token: Token): TokenType {\n    if (isAccessToken(token)) {\n      return 'accessToken';\n    }\n    if (isIDToken(token)) {\n      return 'idToken';\n    }\n    if(isRefreshToken(token)) {\n      return 'refreshToken';\n    }\n    throw new AuthSdkError('Unknown token type');\n  }\n\n  // for synchronization of LocalStorage cross tabs for IE11\n  private emitSetStorageEvent() {\n    if (isIE11OrLess()) {\n      const storage = this.storage.getStorage();\n      this.emitter.emit(EVENT_SET_STORAGE, storage);\n    }\n  }\n\n  // used in `SyncStorageService` for synchronization of LocalStorage cross tabs for IE11\n  public getStorage() {\n    return this.storage;\n  }\n\n  setTokens(\n    tokens: Tokens,\n    // TODO: callbacks can be removed in the next major version OKTA-407224\n    accessTokenCb?: AccessTokenCallback, \n    idTokenCb?: IDTokenCallback,\n    refreshTokenCb?: RefreshTokenCallback\n  ): void {\n    const handleTokenCallback = (key, token) => {\n      const type = this.getTokenType(token);\n      if (type === 'accessToken') {\n        accessTokenCb && accessTokenCb(key, token);\n      } else if (type === 'idToken') {\n        idTokenCb && idTokenCb(key, token);\n      } else if (type === 'refreshToken') {\n        refreshTokenCb && refreshTokenCb(key, token);\n      }\n    };\n    const handleAdded = (key, token) => {\n      this.emitAdded(key, token);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n    const handleRenewed = (key, token, oldToken) => {\n      this.emitRenewed(key, token, oldToken);\n      this.clearExpireEventTimeout(key);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n    const handleRemoved = (key, token) => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, token);\n      handleTokenCallback(key, token);\n    };\n    \n    const types: TokenType[] = ['idToken', 'accessToken', 'refreshToken'];\n    const existingTokens = this.getTokensSync();\n\n    // valid tokens\n    types.forEach((type) => {\n      const token = tokens[type];\n      if (token) {\n        validateToken(token, type);\n      }\n    });\n  \n    // add token to storage\n    const storage = types.reduce((storage, type) => {\n      const token = tokens[type];\n      if (token) {\n        const storageKey = this.getStorageKeyByType(type) || type;\n        storage[storageKey] = token;\n      }\n      return storage;\n    }, {});\n    this.storage.setStorage(storage);\n    this.emitSetStorageEvent();\n\n    // emit event and start expiration timer\n    types.forEach(type => {\n      const newToken = tokens[type];\n      const existingToken = existingTokens[type];\n      const storageKey = this.getStorageKeyByType(type) || type;\n      if (newToken && existingToken) { // renew\n        // call handleRemoved first, since it clears timers\n        handleRemoved(storageKey, existingToken);\n        handleAdded(storageKey, newToken);\n        handleRenewed(storageKey, newToken, existingToken);\n      } else if (newToken) { // add\n        handleAdded(storageKey, newToken);\n      } else if (existingToken) { //remove\n        handleRemoved(storageKey, existingToken);\n      }\n    });\n  }\n  \n  remove(key) {\n    // Clear any listener for this token\n    this.clearExpireEventTimeout(key);\n  \n    var tokenStorage = this.storage.getStorage();\n    var removedToken = tokenStorage[key];\n    delete tokenStorage[key];\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n  \n    this.emitRemoved(key, removedToken);\n  }\n  \n  // TODO: this methods is redundant and can be removed in the next major version OKTA-407224\n  async renewToken(token) {\n    return this.sdk.token?.renew(token);\n  }\n  // TODO: this methods is redundant and can be removed in the next major version OKTA-407224\n  validateToken(token: Token) {\n    return validateToken(token);\n  }\n\n  // TODO: renew method should take no param, change in the next major version OKTA-407224\n  renew(key): Promise<Token | undefined> {\n    // Multiple callers may receive the same promise. They will all resolve or reject from the same request.\n    if (this.state.renewPromise) {\n      return this.state.renewPromise;\n    }\n  \n    try {\n      var token = this.getSync(key);\n      if (!token) {\n        throw new AuthSdkError('The tokenManager has no token for the key: ' + key);\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  \n    // Remove existing autoRenew timeout\n    this.clearExpireEventTimeout(key);\n  \n    // A refresh token means a replace instead of renewal\n    // Store the renew promise state, to avoid renewing again\n    const renewPromise = this.state.renewPromise = this.sdk.token.renewTokens()\n      .then(tokens => {\n        this.setTokens(tokens);\n\n        // resolve token based on the key\n        const tokenType = this.getTokenType(token!);\n        return tokens[tokenType];\n      })\n      .catch(err => {\n        // If renew fails, remove token from storage and emit error\n        this.remove(key);\n        err.tokenKey = key;\n        this.emitError(err);\n        throw err;\n      })\n      .finally(() => {\n        // Remove existing promise key\n        this.state.renewPromise = null;\n      });\n  \n    return renewPromise;\n  }\n  \n  clear() {\n    const tokens = this.getTokensSync();\n    this.clearExpireEventTimeoutAll();\n    this.storage.clearStorage();\n    this.emitSetStorageEvent();\n\n    Object.keys(tokens).forEach(key => {\n      this.emitRemoved(key, tokens[key]);\n    });\n  }\n\n  clearPendingRemoveTokens() {\n    const tokenStorage = this.storage.getStorage();\n    const removedTokens = {};\n    Object.keys(tokenStorage).forEach(key => {\n      if (tokenStorage[key].pendingRemove) {\n        removedTokens[key] = tokenStorage[key];\n        delete tokenStorage[key];\n      }\n    });\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    Object.keys(removedTokens).forEach(key => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, removedTokens[key]);\n    });\n  }\n\n  updateRefreshToken(token: RefreshToken) {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n\n    // do not emit any event\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n  }\n\n  removeRefreshToken () {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n    this.remove(key);\n  }\n\n  addPendingRemoveFlags() {\n    const tokens = this.getTokensSync();\n    Object.keys(tokens).forEach(key => {\n      tokens[key].pendingRemove = true;\n    });\n    this.setTokens(tokens);\n  }\n  \n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}