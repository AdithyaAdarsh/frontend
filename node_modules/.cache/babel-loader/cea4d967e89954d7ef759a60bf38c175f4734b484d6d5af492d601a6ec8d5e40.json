{"ast":null,"code":"import _regeneratorRuntime from \"/Users/aadar00/Documents/image-moderation-app/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/aadar00/Documents/image-moderation-app/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { clone } from '../util/object.js';\nimport { getOAuthUrls } from './util/oauth.js';\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport OAuthError from '../errors/OAuthError.js';\nimport { verifyToken } from './verifyToken.js';\nimport { getDefaultTokenParams } from './util/defaultTokenParams.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport 'cross-fetch';\nimport './types/Token.js';\nfunction validateResponse(res, oauthParams) {\n  if (res['error'] && res['error_description']) {\n    throw new OAuthError(res['error'], res['error_description']);\n  }\n  if (res.state !== oauthParams.state) {\n    throw new AuthSdkError('OAuth flow response state doesn\\'t match request state');\n  }\n}\nfunction handleOAuthResponse(_x, _x2, _x3, _x4) {\n  return _handleOAuthResponse.apply(this, arguments);\n}\nfunction _handleOAuthResponse() {\n  _handleOAuthResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(sdk, tokenParams, res, urls) {\n    var pkce, responseType, scopes, clientId, tokenDict, expiresIn, tokenType, accessToken, idToken, refreshToken, now, accessJwt, idJwt, idTokenObj, validationParams;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          pkce = sdk.options.pkce !== false;\n          if (!(pkce && (res.code || res.interaction_code))) {\n            _context.next = 3;\n            break;\n          }\n          return _context.abrupt(\"return\", sdk.token.exchangeCodeForTokens(Object.assign({}, tokenParams, {\n            authorizationCode: res.code,\n            interactionCode: res.interaction_code\n          }), urls));\n        case 3:\n          tokenParams = tokenParams || getDefaultTokenParams(sdk);\n          urls = urls || getOAuthUrls(sdk, tokenParams);\n          responseType = tokenParams.responseType || [];\n          if (!Array.isArray(responseType) && responseType !== 'none') {\n            responseType = [responseType];\n          }\n          if (res.scope) {\n            scopes = res.scope.split(' ');\n          } else {\n            scopes = clone(tokenParams.scopes);\n          }\n          clientId = tokenParams.clientId || sdk.options.clientId;\n          validateResponse(res, tokenParams);\n          tokenDict = {};\n          expiresIn = res.expires_in;\n          tokenType = res.token_type;\n          accessToken = res.access_token;\n          idToken = res.id_token;\n          refreshToken = res.refresh_token;\n          now = Math.floor(Date.now() / 1000);\n          if (accessToken) {\n            accessJwt = sdk.token.decode(accessToken);\n            tokenDict.accessToken = {\n              accessToken: accessToken,\n              claims: accessJwt.payload,\n              expiresAt: Number(expiresIn) + now,\n              tokenType: tokenType,\n              scopes: scopes,\n              authorizeUrl: urls.authorizeUrl,\n              userinfoUrl: urls.userinfoUrl\n            };\n          }\n          if (refreshToken) {\n            tokenDict.refreshToken = {\n              refreshToken: refreshToken,\n              expiresAt: Number(expiresIn) + now,\n              scopes: scopes,\n              tokenUrl: urls.tokenUrl,\n              authorizeUrl: urls.authorizeUrl,\n              issuer: urls.issuer\n            };\n          }\n          if (!idToken) {\n            _context.next = 27;\n            break;\n          }\n          idJwt = sdk.token.decode(idToken);\n          idTokenObj = {\n            idToken: idToken,\n            claims: idJwt.payload,\n            expiresAt: idJwt.payload.exp - idJwt.payload.iat + now,\n            scopes: scopes,\n            authorizeUrl: urls.authorizeUrl,\n            issuer: urls.issuer,\n            clientId: clientId\n          };\n          validationParams = {\n            clientId: clientId,\n            issuer: urls.issuer,\n            nonce: tokenParams.nonce,\n            accessToken: accessToken,\n            acrValues: tokenParams.acrValues\n          };\n          if (tokenParams.ignoreSignature !== undefined) {\n            validationParams.ignoreSignature = tokenParams.ignoreSignature;\n          }\n          _context.next = 26;\n          return verifyToken(sdk, idTokenObj, validationParams);\n        case 26:\n          tokenDict.idToken = idTokenObj;\n        case 27:\n          if (!(responseType.indexOf('token') !== -1 && !tokenDict.accessToken)) {\n            _context.next = 29;\n            break;\n          }\n          throw new AuthSdkError('Unable to parse OAuth flow response: response type \"token\" was requested but \"access_token\" was not returned.');\n        case 29:\n          if (!(responseType.indexOf('id_token') !== -1 && !tokenDict.idToken)) {\n            _context.next = 31;\n            break;\n          }\n          throw new AuthSdkError('Unable to parse OAuth flow response: response type \"id_token\" was requested but \"id_token\" was not returned.');\n        case 31:\n          return _context.abrupt(\"return\", {\n            tokens: tokenDict,\n            state: res.state,\n            code: res.code,\n            responseType: responseType\n          });\n        case 32:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _handleOAuthResponse.apply(this, arguments);\n}\nexport { handleOAuthResponse };","map":{"version":3,"names":["validateResponse","res","oauthParams","OAuthError","state","AuthSdkError","handleOAuthResponse","_x","_x2","_x3","_x4","_handleOAuthResponse","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","sdk","tokenParams","urls","pkce","responseType","scopes","clientId","tokenDict","expiresIn","tokenType","accessToken","idToken","refreshToken","now","accessJwt","idJwt","idTokenObj","validationParams","wrap","_callee$","_context","prev","next","options","code","interaction_code","abrupt","token","exchangeCodeForTokens","Object","assign","authorizationCode","interactionCode","getDefaultTokenParams","getOAuthUrls","Array","isArray","scope","split","clone","expires_in","token_type","access_token","id_token","refresh_token","Math","floor","Date","decode","claims","payload","expiresAt","Number","authorizeUrl","userinfoUrl","tokenUrl","issuer","exp","iat","nonce","acrValues","ignoreSignature","undefined","verifyToken","indexOf","tokens","stop"],"sources":["/Users/aadar00/Documents/image-moderation-app/frontend/node_modules/@okta/lib/oidc/handleOAuthResponse.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\n/* eslint-disable complexity, max-statements */\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n *\n */\nimport { clone } from '../util';\nimport {\n  getOAuthUrls,\n} from './util/oauth';\nimport { AuthSdkError, OAuthError } from '../errors';\nimport {\n  OktaAuthOAuthInterface,\n  TokenVerifyParams,\n  IDToken,\n  OAuthResponse,\n  TokenParams,\n  TokenResponse,\n  CustomUrls,\n  Tokens,\n} from './types';\nimport { verifyToken } from './verifyToken';\nimport { getDefaultTokenParams } from './util';\n\nfunction validateResponse(res: OAuthResponse, oauthParams: TokenParams) {\n  if (res['error'] && res['error_description']) {\n    throw new OAuthError(res['error'], res['error_description']);\n  }\n\n  if (res.state !== oauthParams.state) {\n    throw new AuthSdkError('OAuth flow response state doesn\\'t match request state');\n  }\n}\n\nexport async function handleOAuthResponse(\n  sdk: OktaAuthOAuthInterface,\n  tokenParams: TokenParams,\n  res: OAuthResponse,\n  urls?: CustomUrls\n): Promise<TokenResponse> {\n  const pkce = sdk.options.pkce !== false;\n\n  // The result contains an authorization_code and PKCE is enabled \n  // `exchangeCodeForTokens` will call /token then call `handleOauthResponse` recursively with the result\n  if (pkce && (res.code || res.interaction_code)) {\n    return sdk.token.exchangeCodeForTokens(Object.assign({}, tokenParams, {\n      authorizationCode: res.code,\n      interactionCode: res.interaction_code\n    }), urls);\n  }\n\n  tokenParams = tokenParams || getDefaultTokenParams(sdk);\n  urls = urls || getOAuthUrls(sdk, tokenParams);\n\n  let responseType = tokenParams.responseType || [];\n  if (!Array.isArray(responseType) && responseType !== 'none') {\n    responseType = [responseType];\n  }\n\n  let scopes;\n  if (res.scope) {\n    scopes = res.scope.split(' ');\n  } else {\n    scopes = clone(tokenParams.scopes);\n  }\n  const clientId = tokenParams.clientId || sdk.options.clientId;\n\n  // Handling the result from implicit flow or PKCE token exchange\n  validateResponse(res, tokenParams);\n\n  const tokenDict = {} as Tokens;\n  const expiresIn = res.expires_in;\n  const tokenType = res.token_type;\n  const accessToken = res.access_token;\n  const idToken = res.id_token;\n  const refreshToken = res.refresh_token;\n  const now = Math.floor(Date.now()/1000);\n\n  if (accessToken) {\n    const accessJwt = sdk.token.decode(accessToken);\n    tokenDict.accessToken = {\n      accessToken: accessToken,\n      claims: accessJwt.payload,\n      expiresAt: Number(expiresIn) + now,\n      tokenType: tokenType!,\n      scopes: scopes,\n      authorizeUrl: urls.authorizeUrl!,\n      userinfoUrl: urls.userinfoUrl!\n    };\n  }\n\n  if (refreshToken) {\n    tokenDict.refreshToken = {\n      refreshToken: refreshToken,\n      // should not be used, this is the accessToken expire time\n      // TODO: remove \"expiresAt\" in the next major version OKTA-407224\n      expiresAt: Number(expiresIn) + now, \n      scopes: scopes,\n      tokenUrl: urls.tokenUrl!,\n      authorizeUrl: urls.authorizeUrl!,\n      issuer: urls.issuer!,\n    };\n  }\n\n  if (idToken) {\n    const idJwt = sdk.token.decode(idToken);\n    const idTokenObj: IDToken = {\n      idToken: idToken,\n      claims: idJwt.payload,\n      expiresAt: idJwt.payload.exp! - idJwt.payload.iat! + now, // adjusting expiresAt to be in local time\n      scopes: scopes,\n      authorizeUrl: urls.authorizeUrl!,\n      issuer: urls.issuer!,\n      clientId: clientId!\n    };\n\n    const validationParams: TokenVerifyParams = {\n      clientId: clientId!,\n      issuer: urls.issuer!,\n      nonce: tokenParams.nonce,\n      accessToken: accessToken,\n      acrValues: tokenParams.acrValues\n    };\n\n    if (tokenParams.ignoreSignature !== undefined) {\n      validationParams.ignoreSignature = tokenParams.ignoreSignature;\n    }\n\n    await verifyToken(sdk, idTokenObj, validationParams);\n    tokenDict.idToken = idTokenObj;\n  }\n\n  // Validate received tokens against requested response types \n  if (responseType.indexOf('token') !== -1 && !tokenDict.accessToken) {\n    // eslint-disable-next-line max-len\n    throw new AuthSdkError('Unable to parse OAuth flow response: response type \"token\" was requested but \"access_token\" was not returned.');\n  }\n  if (responseType.indexOf('id_token') !== -1 && !tokenDict.idToken) {\n    // eslint-disable-next-line max-len\n    throw new AuthSdkError('Unable to parse OAuth flow response: response type \"id_token\" was requested but \"id_token\" was not returned.');\n  }\n\n  return {\n    tokens: tokenDict,\n    state: res.state!,\n    code: res.code,\n    responseType\n  };\n  \n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}