{"ast":null,"code":"/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport { isRefreshToken } from '../oidc/types/Token.js';\nimport { EVENT_EXPIRED } from '../oidc/types/TokenManager.js';\nimport { isBrowser } from '../features.js';\nclass AutoRenewService {\n  constructor(tokenManager, options = {}) {\n    this.started = false;\n    this.tokenManager = tokenManager;\n    this.options = options;\n    this.renewTimeQueue = [];\n    this.onTokenExpiredHandler = this.onTokenExpiredHandler.bind(this);\n  }\n  shouldThrottleRenew() {\n    let res = false;\n    this.renewTimeQueue.push(Date.now());\n    if (this.renewTimeQueue.length >= 10) {\n      const firstTime = this.renewTimeQueue.shift();\n      const lastTime = this.renewTimeQueue[this.renewTimeQueue.length - 1];\n      res = lastTime - firstTime < 30 * 1000;\n    }\n    return res;\n  }\n  requiresLeadership() {\n    return !!this.options.syncStorage && isBrowser();\n  }\n  processExpiredTokens() {\n    const tokenStorage = this.tokenManager.getStorage();\n    const tokens = tokenStorage.getStorage();\n    Object.keys(tokens).forEach(key => {\n      const token = tokens[key];\n      if (!isRefreshToken(token) && this.tokenManager.hasExpired(token)) {\n        this.onTokenExpiredHandler(key);\n      }\n    });\n  }\n  onTokenExpiredHandler(key) {\n    if (this.options.autoRenew) {\n      if (this.shouldThrottleRenew()) {\n        const error = new AuthSdkError('Too many token renew requests');\n        this.tokenManager.emitError(error);\n      } else {\n        this.tokenManager.renew(key).catch(() => {});\n      }\n    } else if (this.options.autoRemove) {\n      this.tokenManager.remove(key);\n    }\n  }\n  canStart() {\n    return (!!this.options.autoRenew || !!this.options.autoRemove) && !this.started;\n  }\n  async start() {\n    if (this.canStart()) {\n      this.tokenManager.on(EVENT_EXPIRED, this.onTokenExpiredHandler);\n      if (this.tokenManager.isStarted()) {\n        this.processExpiredTokens();\n      }\n      this.started = true;\n    }\n  }\n  async stop() {\n    if (this.started) {\n      this.tokenManager.off(EVENT_EXPIRED, this.onTokenExpiredHandler);\n      this.renewTimeQueue = [];\n      this.started = false;\n    }\n  }\n  isStarted() {\n    return this.started;\n  }\n}\nexport { AutoRenewService };","map":{"version":3,"names":["AutoRenewService","constructor","tokenManager","options","started","renewTimeQueue","onTokenExpiredHandler","bind","shouldThrottleRenew","res","push","Date","now","length","firstTime","shift","lastTime","requiresLeadership","syncStorage","isBrowser","processExpiredTokens","tokenStorage","getStorage","tokens","Object","keys","forEach","key","token","isRefreshToken","hasExpired","autoRenew","error","AuthSdkError","emitError","renew","catch","autoRemove","remove","canStart","start","on","EVENT_EXPIRED","isStarted","stop","off"],"sources":["/Users/aadar00/Library/CloudStorage/OneDrive-BlackhawkNetwork,Inc/Documents/image-moderation-app/frontend/node_modules/@okta/lib/services/AutoRenewService.ts"],"sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\n\nimport { AuthSdkError } from '../errors';\nimport { ServiceInterface, ServiceManagerOptions } from '../core/types';\nimport { EVENT_EXPIRED, TokenManagerInterface, isRefreshToken } from '../oidc/types';\nimport { isBrowser } from '../features';\n\nexport class AutoRenewService implements ServiceInterface {\n  private tokenManager: TokenManagerInterface;\n  private options: ServiceManagerOptions;\n  private renewTimeQueue: Array<number>;\n  private started = false;\n\n  constructor(tokenManager: TokenManagerInterface, options: ServiceManagerOptions = {}) {\n    this.tokenManager = tokenManager;\n    this.options = options;\n    this.renewTimeQueue = [];\n    this.onTokenExpiredHandler = this.onTokenExpiredHandler.bind(this);\n  }\n  \n  private shouldThrottleRenew(): boolean {\n    let res = false;\n    this.renewTimeQueue.push(Date.now());\n    if (this.renewTimeQueue.length >= 10) {\n      // get and remove first item from queue\n      const firstTime = this.renewTimeQueue.shift() as number;\n      const lastTime = this.renewTimeQueue[this.renewTimeQueue.length - 1];\n      res = (lastTime - firstTime) < 30 * 1000;\n    }\n    return res;\n  }\n\n  requiresLeadership() {\n    // If tokens sync storage is enabled, handle tokens expiration only in 1 leader tab\n    return !!this.options.syncStorage && isBrowser();\n  }\n\n  private processExpiredTokens() {\n    const tokenStorage = this.tokenManager.getStorage();\n    const tokens = tokenStorage.getStorage();\n    Object.keys(tokens).forEach(key => {\n      const token = tokens[key];\n      if (!isRefreshToken(token) && this.tokenManager.hasExpired(token)) {\n        this.onTokenExpiredHandler(key);\n      }\n    });\n  }\n\n  private onTokenExpiredHandler(key: string) {\n    if (this.options.autoRenew) {\n      if (this.shouldThrottleRenew()) {\n        const error = new AuthSdkError('Too many token renew requests');\n        this.tokenManager.emitError(error);\n      } else {\n        this.tokenManager.renew(key).catch(() => {}); // Renew errors will emit an \"error\" event \n      }\n    } else if (this.options.autoRemove) {\n      this.tokenManager.remove(key);\n    }\n  }\n\n  canStart() {\n    return (!!this.options.autoRenew || !!this.options.autoRemove) && !this.started;\n  }\n\n  async start() {\n    if (this.canStart()) {\n      this.tokenManager.on(EVENT_EXPIRED, this.onTokenExpiredHandler);\n      if (this.tokenManager.isStarted()) {\n        // If token manager has been already started, we could miss token expire events,\n        //  so need to process expired tokens manually.\n        this.processExpiredTokens();\n      }\n      this.started = true;\n    }\n  }\n\n  async stop() {\n    if (this.started) {\n      this.tokenManager.off(EVENT_EXPIRED, this.onTokenExpiredHandler);\n      this.renewTimeQueue = [];\n      this.started = false;\n    }\n  }\n\n  isStarted() {\n    return this.started;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;MAkBaA,gBAAgB;EAM3BC,WAAYA,CAAAC,YAAmC,EAAEC,OAAA,GAAiC,EAAE;IAF5E,IAAO,CAAAC,OAAA,GAAG,KAAK;IAGrB,IAAI,CAACF,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACE,cAAc,GAAG,EAAE;IACxB,IAAI,CAACC,qBAAqB,GAAG,IAAI,CAACA,qBAAqB,CAACC,IAAI,CAAC,IAAI,CAAC;EACnE;EAEOC,mBAAmBA,CAAA;IACzB,IAAIC,GAAG,GAAG,KAAK;IACf,IAAI,CAACJ,cAAc,CAACK,IAAI,CAACC,IAAI,CAACC,GAAG,CAAE,EAAC;IACpC,IAAI,IAAI,CAACP,cAAc,CAACQ,MAAM,IAAI,EAAE,EAAE;MAEpC,MAAMC,SAAS,GAAG,IAAI,CAACT,cAAc,CAACU,KAAK,EAAY;MACvD,MAAMC,QAAQ,GAAG,IAAI,CAACX,cAAc,CAAC,IAAI,CAACA,cAAc,CAACQ,MAAM,GAAG,CAAC,CAAC;MACpEJ,GAAG,GAAIO,QAAQ,GAAGF,SAAS,GAAI,EAAE,GAAG,IAAI;IACzC;IACD,OAAOL,GAAG;EACX;EAEDQ,kBAAkBA,CAAA;IAEhB,OAAO,CAAC,CAAC,IAAI,CAACd,OAAO,CAACe,WAAW,IAAIC,SAAS,EAAE;EACjD;EAEOC,oBAAoBA,CAAA;IAC1B,MAAMC,YAAY,GAAG,IAAI,CAACnB,YAAY,CAACoB,UAAU,EAAE;IACnD,MAAMC,MAAM,GAAGF,YAAY,CAACC,UAAU,EAAE;IACxCE,MAAM,CAACC,IAAI,CAACF,MAAM,CAAC,CAACG,OAAO,CAACC,GAAG,IAAG;MAChC,MAAMC,KAAK,GAAGL,MAAM,CAACI,GAAG,CAAC;MACzB,IAAI,CAACE,cAAc,CAACD,KAAK,CAAC,IAAI,IAAI,CAAC1B,YAAY,CAAC4B,UAAU,CAACF,KAAK,CAAC,EAAE;QACjE,IAAI,CAACtB,qBAAqB,CAACqB,GAAG,CAAC;MAChC;IACH,CAAC,CAAC;EACH;EAEOrB,qBAAqBA,CAACqB,GAAW;IACvC,IAAI,IAAI,CAACxB,OAAO,CAAC4B,SAAS,EAAE;MAC1B,IAAI,IAAI,CAACvB,mBAAmB,EAAE,EAAE;QAC9B,MAAMwB,KAAK,GAAG,IAAIC,YAAY,CAAC,+BAA+B,CAAC;QAC/D,IAAI,CAAC/B,YAAY,CAACgC,SAAS,CAACF,KAAK,CAAC;MACnC,OAAM;QACL,IAAI,CAAC9B,YAAY,CAACiC,KAAK,CAACR,GAAG,CAAC,CAACS,KAAK,CAAC,MAAK,EAAG,CAAC;MAC7C;IACF,OAAM,IAAI,IAAI,CAACjC,OAAO,CAACkC,UAAU,EAAE;MAClC,IAAI,CAACnC,YAAY,CAACoC,MAAM,CAACX,GAAG,CAAC;IAC9B;EACF;EAEDY,QAAQA,CAAA;IACN,OAAO,CAAC,CAAC,CAAC,IAAI,CAACpC,OAAO,CAAC4B,SAAS,IAAI,CAAC,CAAC,IAAI,CAAC5B,OAAO,CAACkC,UAAU,KAAK,CAAC,IAAI,CAACjC,OAAO;EAChF;EAED,MAAMoC,KAAKA,CAAA;IACT,IAAI,IAAI,CAACD,QAAQ,EAAE,EAAE;MACnB,IAAI,CAACrC,YAAY,CAACuC,EAAE,CAACC,aAAa,EAAE,IAAI,CAACpC,qBAAqB,CAAC;MAC/D,IAAI,IAAI,CAACJ,YAAY,CAACyC,SAAS,EAAE,EAAE;QAGjC,IAAI,CAACvB,oBAAoB,EAAE;MAC5B;MACD,IAAI,CAAChB,OAAO,GAAG,IAAI;IACpB;EACF;EAED,MAAMwC,IAAIA,CAAA;IACR,IAAI,IAAI,CAACxC,OAAO,EAAE;MAChB,IAAI,CAACF,YAAY,CAAC2C,GAAG,CAACH,aAAa,EAAE,IAAI,CAACpC,qBAAqB,CAAC;MAChE,IAAI,CAACD,cAAc,GAAG,EAAE;MACxB,IAAI,CAACD,OAAO,GAAG,KAAK;IACrB;EACF;EAEDuC,SAASA,CAAA;IACP,OAAO,IAAI,CAACvC,OAAO;EACpB;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}